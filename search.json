[
  {
    "objectID": "routing.html",
    "href": "routing.html",
    "title": "Routing",
    "section": "",
    "text": "OD data\n\n\n\nIf you have travel survey data, for some exercises you may use that one. See also Jittering, if needed.\nFor all the other, we can simply use census data.\n\n\nWhen using census data, for this exercises we can consider all-to-all origins and destinations\n\nlibrary(sf)\nlibrary(mapview)\nPOINTS = st_read(\"data/Lisbon/Censos_Lx.gpkg\")\nnrow(POINTS) # 2822\nsum(POINTS$residents) # 545.796\n\nWith census data, each statistical unit represents ~300 residents. In Lisbon, we have 2822 census units.\nRouting between all origins and destinations (2822 x 2822 = 7.963.684 OD pairs) can potentially be a long-duration process. Nothing that r5r wouldn‚Äôt handle! üôÇ\nBut here we will consider a city_center location, and route our census population to the city center. Search in an online map the coordinates for a point that you would like to consider your attractor.\n\n# Create origin point - Baixa / Downtown\ncity_center = data.frame(id = \"1\", lat = 38.711884, lon = -9.137313) |&gt;\n  st_as_sf(coords = c('lon', 'lat'), crs = 4326)\ncity_center$lon = st_coordinates(city_center)[,1]\ncity_center$lat = st_coordinates(city_center)[,2]",
    "crumbs": [
      "Home",
      "r5r",
      "Routing"
    ]
  },
  {
    "objectID": "routing.html#origins-and-destinations",
    "href": "routing.html#origins-and-destinations",
    "title": "Routing",
    "section": "",
    "text": "OD data\n\n\n\nIf you have travel survey data, for some exercises you may use that one. See also Jittering, if needed.\nFor all the other, we can simply use census data.\n\n\nWhen using census data, for this exercises we can consider all-to-all origins and destinations\n\nlibrary(sf)\nlibrary(mapview)\nPOINTS = st_read(\"data/Lisbon/Censos_Lx.gpkg\")\nnrow(POINTS) # 2822\nsum(POINTS$residents) # 545.796\n\nWith census data, each statistical unit represents ~300 residents. In Lisbon, we have 2822 census units.\nRouting between all origins and destinations (2822 x 2822 = 7.963.684 OD pairs) can potentially be a long-duration process. Nothing that r5r wouldn‚Äôt handle! üôÇ\nBut here we will consider a city_center location, and route our census population to the city center. Search in an online map the coordinates for a point that you would like to consider your attractor.\n\n# Create origin point - Baixa / Downtown\ncity_center = data.frame(id = \"1\", lat = 38.711884, lon = -9.137313) |&gt;\n  st_as_sf(coords = c('lon', 'lat'), crs = 4326)\ncity_center$lon = st_coordinates(city_center)[,1]\ncity_center$lat = st_coordinates(city_center)[,2]",
    "crumbs": [
      "Home",
      "r5r",
      "Routing"
    ]
  },
  {
    "objectID": "routing.html#ttm",
    "href": "routing.html#ttm",
    "title": "Routing",
    "section": "Travel Time Matrix",
    "text": "Travel Time Matrix\n\n# load packages\nlibrary(tidyverse)\noptions(java.parameters = '-Xmx16G') # RAM to 16GB\nlibrary(r5r)\n\n# read network\nr5r_lisboa = build_network(\"data/Lisbon/r5r\")\n\nThere are many options to choose from when estimating a travel_time_matrix.\n\nCar\nLet‚Äôs begin with a uni-modal option: Car, and no time restrictions.\n\ndeparture_datetime = as.POSIXct(\"01-10-2025 10:00:00\", format = \"%d-%m-%Y %H:%M:%S\")\nttm_car = travel_time_matrix(r5r_network = r5r_lisboa,\n                              origins = city_center,\n                              destinations = POINTS,\n                              mode = \"CAR\",\n                              departure_datetime = departure_datetime,\n                              verbose = FALSE)\n\nnrow(ttm_car) # 2822\n\nIt was super fast to estimate the travel time for 2822 trips!\n\nsummary(ttm_car$travel_time_p50)\nhist(ttm_car$travel_time_p50)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n   0.00    9.00   12.00   11.41   14.00   26.00 \n\n\n\n\n\nBy car, all the 2822 points with residents are able to be reach from city center.\nIn free-flow, the longest trip takes 26 minutes. 50% of the trips are shorter than 12 minutes.\n\n\nWalk\nLet‚Äôs see how it does for walking trips‚Ä¶\n\nttm_walk = travel_time_matrix(r5r_network = r5r_lisboa,\n                              origins = city_center,\n                              destinations = POINTS,\n                              mode = \"WALK\",\n                              departure_datetime = departure_datetime,\n                              max_trip_duration = 120, # 2 hours\n                              verbose = FALSE)\n\nnrow(ttm_walk) # 2073\nnrow(ttm_walk) / nrow(POINTS) # 73 %\nPOINTS |&gt; \n  semi_join(ttm_walk, by = c(\"id\" = \"to_id\"))  |&gt; \n  pull(residents) |&gt; \n  sum() # 391.358\n\nOnly 2073 destinations were able to be reached in the 2h time window (73%), representing 177,466 residents (72%)\n\n\nCode\nsummary(ttm_walk$travel_time_p50)\nhist(ttm_walk$travel_time_p50)\n\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n   0.00   31.00   56.00   59.13   88.00  120.00 \n\n\n\n\n\nThe longest trip takes 120 minutes (equal to the max travel time). The time distribution is pretty even.\n\n\nBike\nWhen considering bike trips, we can also set a maximum level of traffic stress (Mekuria, Furth, and Nixon 2012) that cyclists will tolerate.\n\nLTS\nA value of 1 means cyclists will only travel through the quietest streets, while a value of 4 indicates cyclists can travel through any road. Defaults to 2, which can be very restrictive in Lisbon (depends on your case study).\nFrom Pereira et al. (2021):\nWhen cycling is enabled in R5 (by passing the value BIKE to either mode or mode_egress), setting max_lts will allow cycling only on streets with a given level of danger/stress. Setting max_lts to 1, for example, will allow cycling only on separated bicycle infrastructure or low-traffic streets and routing will revert to walking when traversing any links with LTS exceeding 1. Setting max_lts to 3 will allow cycling on links with LTS 1, 2 or 3. Routing also reverts to walking if the street segment is tagged as non-bikable in OSM (e.g.¬†a staircase), independently of the specified max LTS.\nThe default methodology for assigning LTS values to network edges is based on commonly tagged attributes of OSM ways. See more info about LTS in the original documentation of R5 from Conveyal at https://docs.conveyal.com/learn-more/traffic-stress. In summary:\n\nLTS 1: Tolerable for children. This includes low-speed, low-volume streets, as well as those with separated bicycle facilities (such as parking-protected lanes or cycle tracks).\nLTS 2: Tolerable for the mainstream adult population. This includes streets where cyclists have dedicated lanes and only have to interact with traffic at formal crossing.\nLTS 3: Tolerable for ‚Äúenthused and confident‚Äù cyclists. This includes streets which may involve close proximity to moderate- or high-speed vehicular traffic.\nLTS 4: Tolerable only for ‚Äústrong and fearless‚Äù cyclists. This includes streets where cyclists are required to mix with moderate- to high-speed vehicular traffic.\n\nFor advanced users, you can provide custom LTS values by adding a tag &lt;key = \"lts\"&gt; to the osm.pbf file.\n\nttm_bike = travel_time_matrix(r5r_network = r5r_lisboa,\n                              origins = city_center,\n                              destinations = POINTS,\n                              mode = \"BICYCLE\",\n                              max_lts = 3,\n                              departure_datetime = departure_datetime,\n                              max_trip_duration = 60,\n                              verbose = FALSE)\n\nnrow(ttm_bike) # 2751\nnrow(ttm_bike) / nrow(POINTS) # 97 %\n\nAlmost all destinations were able to be reached in the 1h time window (97%).\n\n\nCode\nsummary(ttm_bike$travel_time_p50)\n\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n   0.00   16.00   31.00   30.54   46.00   60.00 \n50% of the trips are shorter than 31 minutes.\n\n\n\nPublic Transit\nWhen estimating travel time with public transit, some considerations should be provided.\n\nDate and time of the trips\nWhich modes are allowed? All or just some of PT?\nHow many transfers are allowed\nHow to get to the PT stop? By foot, bike or car? The same from the last stop to the destination\nHow many minutes it is reasonable to walk (of bike) in max during the whole trip?\nIs my best time-travel estimate the same, if I consider a 5min time-window period or a 30min time-window period?\n\n\nDate and time\nThis is a very relevant parameter (departure_datetime). If your selected date is not part of your GTFS calendar, you will not be able to estimate travel by PT on those dates.\n\nConfirm service calendar\n\nlibrary(tidytransit)\n# gtfs_carris = tidytransit::read_gtfs(\"data/Lisbon/r5r/carris_gtfs.zip\")\nsummary(gtfs_carris)\n\ntidygtfs object\nfiles        agency, stops, routes, trips, stop_times, calendar, calendar_dates, shapes, transfers\nagency       Carris\nservice      from 2025-09-01 to 2025-12-01\nuses         stop_times (no frequencies)\n# routes       175\n# trips      53028\n# stop_ids    2341\n# stop_names  1139\n# shapes       307\nMy GTFS runs from 2025-09-01 to 2025-12-01. I will select a working day, and a peak hour for this exercises.\n\ndeparture_datetime = as.POSIXct(\"01-10-2025 08:00:00\", # wednesday\n                                format = \"%d-%m-%Y %H:%M:%S\")\n\nWhen I change this parameter, my results may be totally different.\n\n\n\nModes\nR5 allows for multiple combinations of transport modes. The options include:\n\nTransit modes: TRAM, SUBWAY, RAIL, BUS, FERRY, CABLE_CAR, GONDOLA, FUNICULAR.\nThe option TRANSIT automatically considers all public transport modes available.\nNon transit modes: WALK, BICYCLE, CAR, BICYCLE_RENT, CAR_PARK.\n\n\n\nTransfers\nThe maximum number of public transport rides allowed in the same trip. The max_rides defaults to 3. Consider a plausible number, and take into consideration that shifting from one metro line to other will be considered as 2 rides.\n\n\nEgress mode and max walk time\nThe transport mode used after egress from the last public transport.\nIt can be either WALK, BICYCLE or CAR.\nDefaults to WALK. Ignored when public transport is not used.\nThe max_walk_time (or bike or car) time (in minutes) to access and egress the transit network, to make transfers within the network or to complete walk-only trips.\nWhen routing transit trips, the max time is considered separately for each leg (e.g.¬†if you set max_walk_time to 15, you could get trips with an up to 15 minutes walk leg to reach transit and another up to 15 minutes walk leg to reach the destination after leaving transit.\n\n\nTime window\nTo calculate the travel time from A to B, or to calculate the accessibility level at a given location, one has to select a departure time.\nEven a small difference, say leaving at 10:00am or 10:04am might importantly change travel time and accessibility estimates depending on when a person departs relative to when a public transport vehicle arrives, and how well transfers are coordinated given a service timetable.\nWhen time_window is set, R5 computes multiple travel times / accessibility estimates starting at the specified departure_datetime and within the time_window selected by the user. By default, r5r will generate one estimate per minute.\nBy default, r5r results have the 50th percentile of travel time.\nSee more in time_window (Pereira et al. 2021).\nLet‚Äôs see an example:\n\nttm_transit = travel_time_matrix(\n  r5r_network = r5r_lisboa,\n  origins = city_center,\n  destinations = POINTS,\n  mode = \"TRANSIT\", # or BUS or SUBWAY or RAIL or FERRY only\n  # mode = c(\"SUBWAY\", \"BUS\") # the same as above\n  mode_egress = \"WALK\",\n  departure_datetime = departure_datetime,\n  max_rides = 3, # 2 transfers\n  # time_window = 10, # the default\n  max_walk_time = 15,\n  max_trip_duration = 60,\n  verbose = FALSE\n)\n\nnrow(ttm_transit) # 2795\nnrow(ttm_transit) / nrow(POINTS) # 99 %\nPOINTS |&gt; \n  semi_join(ttm_transit, by = c(\"id\" = \"to_id\"))  |&gt; \n  pull(residents) |&gt; \n  sum() # 269.539\n\nAlmost all destinations were able to be reached in the 1h time window (99%).\n\n\nCode\nsummary(ttm_transit$travel_time_p50)\n\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n   0.00   24.00   31.00   31.63   41.00   59.00 \n\n50% of the trips take less than 31 minutes. The distribution is pretty normal.\n\n\n\n\n\n\nTry to change some parameters, such as the max_rides or the max_trip_duration and compare the results.",
    "crumbs": [
      "Home",
      "r5r",
      "Routing"
    ]
  },
  {
    "objectID": "routing.html#detailed-itineraries",
    "href": "routing.html#detailed-itineraries",
    "title": "Routing",
    "section": "Detailed itineraries",
    "text": "Detailed itineraries\nWith the detailed_itineraries(), we can extract more information about each trip, such as:\n\nWhich modes were used for trip x? In which order?\nWhat is the duration for each leg?\nWhich route (shape) was estimated?\n\nThis function is also pretty flexible and allows to see more details. Also, because of this, it may require some more processing cost.\n\nMulti-modal legs\nUsing the same parameters as the ttm_transit, let‚Äôs see more details\n\ndetailed_transit = detailed_itineraries(\n  r5r_network = r5r_lisboa,\n  origins = city_center,\n  destinations = POINTS,\n  mode = \"TRANSIT\",\n  mode_egress = \"WALK\",\n  departure_datetime = departure_datetime,\n  max_rides = 2, # 1 transfers\n  # time_window = 10, # the default\n  max_walk_time = 30,\n  max_trip_duration = 60,\n  drop_geometry = TRUE, # no geometry this time (processig time)\n  verbose = FALSE\n)\n\ntable(detailed_transit$mode)\nView(detailed_transit)\n\n   BUS SUBWAY   WALK \n  1653   2646   7058 \n    from_id from_lat  from_lon  to_id   to_lat    to_lon option departure_time total_duration total_distance segment   mode\n     &lt;char&gt;    &lt;num&gt;     &lt;num&gt; &lt;char&gt;    &lt;num&gt;     &lt;num&gt;  &lt;int&gt;         &lt;char&gt;          &lt;num&gt;          &lt;int&gt;   &lt;int&gt; &lt;char&gt;\n 1:       1 38.71188 -9.137313      1 38.73367 -9.131977      1       08:07:58           16.4           3241       1   WALK\n 2:       1 38.71188 -9.137313      1 38.73367 -9.131977      1       08:07:58           16.4           3241       2 SUBWAY\n 3:       1 38.71188 -9.137313      1 38.73367 -9.131977      1       08:07:58           16.4           3241       3   WALK\n 4:       1 38.71188 -9.137313      2 38.73378 -9.147983      1       08:07:58           19.7           3297       1   WALK\n 5:       1 38.71188 -9.137313      2 38.73378 -9.147983      1       08:07:58           19.7           3297       2 SUBWAY\n 6:       1 38.71188 -9.137313      2 38.73378 -9.147983      1       08:07:58           19.7           3297       3   WALK\n 7:       1 38.71188 -9.137313      3 38.69891 -9.219046      1       08:04:02           52.1           8471       1   WALK\n 8:       1 38.71188 -9.137313      3 38.69891 -9.219046      1       08:04:02           52.1           8471       2 SUBWAY\n 9:       1 38.71188 -9.137313      3 38.69891 -9.219046      1       08:04:02           52.1           8471       3   WALK\n10:       1 38.71188 -9.137313      3 38.69891 -9.219046      1       08:04:02           52.1           8471       4    BUS\n11:       1 38.71188 -9.137313      3 38.69891 -9.219046      1       08:04:02           52.1           8471     \n    segment_duration  wait distance  route\n               &lt;num&gt; &lt;num&gt;    &lt;int&gt; &lt;char&gt;\n 1:              4.5   0.0      343       \n 2:              5.9   1.5     2640      C\n 3:              4.5   0.0      258       \n 4:              4.5   0.0      343       \n 5:              5.1   1.1     2429      A\n 6:              9.0   0.0      525       \n 7:              4.5   0.0      343       \n 8:              1.3   1.5      719      C\n 9:              1.6   0.0      109       \n10:             32.0   3.1     6821   76_0\n11:              8.1   0.0      479       \n\n\nRoute shapes\nLet‚Äôs see in detail the first 3 OD pairs:\n\ndetailed_transit_sample = detailed_itineraries(\n  r5r_network = r5r_lisboa,\n  origins = city_center,\n  destinations = POINTS[c(1:3),], # only the first 3 points\n  mode = \"TRANSIT\",\n  mode_egress = \"WALK\",\n  departure_datetime = departure_datetime,\n  max_rides = 2, # 1 transfers\n  # time_window = 10, # the default\n  max_walk_time = 30,\n  max_trip_duration = 60,\n  # drop_geometry = TRUE, # no geometry this time (processig time)\n  verbose = FALSE,\n  progress = TRUE\n)\n\nmapview(detailed_transit_sample, zcol = \"mode\")\n\n\nClick on each segment to analyse the details, in particular the segment duration and distance, the waiting time, the leg order, and the transit route number / name.",
    "crumbs": [
      "Home",
      "r5r",
      "Routing"
    ]
  },
  {
    "objectID": "routing.html#circuity",
    "href": "routing.html#circuity",
    "title": "Routing",
    "section": "Circuity",
    "text": "Circuity\nCircuity measures how direct or indirect a travel route is compared to the straight-line (Euclidean) distance between an origin and a destination. It reflects the efficiency of the transport network in providing direct connections.\nThe circuity index (C) measures how indirect a route is compared to the straight-line distance between an origin and a destination, and is defined as:\n\\[\nC = \\frac{d_{\\text{network}}}{d_{\\text{euclidean}}}\n\\]\nwhere:\n\n\\(d_{network}\\) ‚Äî distance or travel length along the actual transport network\n\\(d_{euclidean}\\) ‚Äî straight-line (Euclidean) distance between the same points\n\nA circuity value of 1 indicates a perfectly direct route (as the crow flies), while higher values indicate more detoured paths due to network layout, barriers, or design.\nIn this exercise, circuity will be estimated separately for car, walking, cycling, and public transport networks, allowing comparison of how each mode‚Äôs infrastructure shapes travel efficiency and accessibility.\n\nEuclidean distances\nFirst we will create lines connecting the survey locations to the university, using the st_nearest_points() function. This function finds returns the nearest points between two geometries, and creates a line between them.\n\ndist_euclidean = st_nearest_points(POINTS, BAIXA, pairwise = TRUE) |&gt;\n  st_as_sf() # this creates lines\n\nmapview(dist_euclidean, lwd = 0.2)\n\n\n\n\n\n\nNow we can estimate the distance using the st_length() function.\n\n# compute the line length\ndist_euclidean = POINTS |&gt;  \n  mutate(distance = st_length(dist_euclidean) |&gt; units::drop_units() |&gt; round()) |&gt; \n  st_drop_geometry() # not needed\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n     41    2071    3962    4178    6385    9814 \n\n\nRouting by mode\nWe will process only for the walk, car and bike routes.\n\n# Walk\ndist_walk = detailed_itineraries(\n  r5r_network = r5r_lisboa,\n  origins = city_center,\n  destinations = POINTS,\n  mode = \"WALK\",\n  drop_geometry = TRUE\n)\n\n# Car\ndist_car = detailed_itineraries(\n  r5r_network = r5r_lisboa,\n  origins = city_center,\n  destinations = POINTS,\n  mode = \"CAR\",\n  drop_geometry = TRUE\n)\n\n# Bike\ndist_bike = detailed_itineraries(\n  r5r_network = r5r_lisboa,\n  origins = city_center,\n  destinations = POINTS,\n  mode = \"BICYCLE\",\n  max_lts = 3,\n  drop_geometry = TRUE\n)\n\n\n\nCompare distances\nWe can compare all the distances for trips under 2h.\n\n\nCode\nDISTANCES = dist_euclidean |&gt; \n  left_join(dist_walk |&gt;\n              select(to_id, total_distance) |&gt;\n              rename(walk_dist = total_distance,\n                     id = to_id)) |&gt;\n  left_join(dist_car |&gt;\n              select(to_id, total_distance) |&gt;\n              rename(car_dist = total_distance,\n                     id = to_id)) |&gt;\n  left_join(dist_bike |&gt;\n              select(to_id, total_distance) |&gt;\n              rename(bike_dist = total_distance,\n                     id = to_id)) \n\nDISTANCES = DISTANCES |&gt;\n  mutate(circ_walk = walk_dist / distance,\n        circ_car  = car_dist / distance,\n        circ_bike = bike_dist / distance)\n\n\n\nsummary(DISTANCES$circ_walk)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max.    NA's \n  1.018   1.131   1.186   1.252   1.302   4.024     757 \n  \n\nsummary(DISTANCES$circ_car)\n\n  Min.  1st Qu.   Median     Mean  3rd Qu.     Max.     NA's \n 0.04975  1.36537  1.59976  1.90545  1.96105 51.04878        3 \n\nsummary(DISTANCES$circ_bike)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max.    NA's \n  1.059   1.252   1.320   1.383   1.446   4.780       1 \n\nCircuity &gt;1 indicates that network routes are longer than straight-line distances.\n\n\n\nCode\ndata2 = DISTANCES |&gt;\n  select(distance, walk_dist, bike_dist, car_dist) |&gt;\n  na.omit() # remove the ones that were not estimated for all modes\nboxplot(data2, main=\"Distance by Mode\",\n        ylab=\"Distance (meters)\",\n        col=c(\"lightblue\", \"lightgreen\", \"lightpink\", \"lightyellow\"),\n        names=c(\"Euclidean\", \"Walk\", \"Bike\", \"Car\"))\n\n\n\n\n\n\n\nLet‚Äôs visualize for one example\n\n# id = 1594\n\n# Walk\ndist_walk_example = detailed_itineraries(\n  r5r_network = r5r_lisboa,\n  origins = city_center,\n  destinations = POINTS[1594,],\n  mode = \"WALK\"\n)\n\n# Car\ndist_car_example = detailed_itineraries(\n  r5r_network = r5r_lisboa,\n  origins = city_center,\n  destinations = POINTS[1594,],\n  mode = \"CAR\"\n)\n\n# Bike\ndist_bike_example = detailed_itineraries(\n  r5r_network = r5r_lisboa,\n  origins = city_center,\n  destinations = POINTS[1594,],\n  mode = \"BICYCLE\",\n  max_lts = 3\n)\n\nmapview(dist_walk_example, color = \"black\") + # 984 meters\n  mapview(dist_bike_example, color = \"blue\") + # 1262 meters\n  mapview(dist_car_example, color = \"red\") # 3161 meters",
    "crumbs": [
      "Home",
      "r5r",
      "Routing"
    ]
  },
  {
    "objectID": "routing.html#overline",
    "href": "routing.html#overline",
    "title": "Routing",
    "section": "Overline",
    "text": "Overline\nWe can add population or other information to the routes, to visualize which ones could potentially have more demand.\nFor that, I‚Äôll run the process for 300 random destinations, by WALK:\n\ndetailed_walk_sample_300 = detailed_itineraries(\n  r5r_network = r5r_lisboa,\n  origins = city_center,\n  destinations = POINTS |&gt; sample_n(300), # 300 sample\n  mode = \"WALK\",\n  # drop_geometry = TRUE, # no geometry this time (processig time)\n  verbose = FALSE,\n  progress = TRUE\n)\n\nView(detailed_transit_sample_300)\n\nmapview(detailed_transit_sample_300, alpha = 0.5)\n\n\nNow, join this information with the population\n\ndetailed_walk_sample_300 = detailed_walk_sample_300 |&gt;\n  left_join(POINTS |&gt; st_drop_geometry(), # can't be an sf\n          by = c(\"to_id\" = \"id\"))\n\nLet‚Äôs overline all the linestrings, by adding the ‚Äúresidents‚Äù variable (Lovelace and Ellison 2018)\n\nlibrary(stplanr)\ndetailed_walk_sample_300_overline = detailed_walk_sample_300 |&gt; \n  overline2(attrib = \"residents\",\n            fun = sum)\n\nsummary(detailed_walk_sample_300_overline$residents)\nmapview(detailed_walk_sample_300_overline)\n\n\n\n\n\n\n\n\nNote\n\n\n\nNote the odd lines and the route choices.",
    "crumbs": [
      "Home",
      "r5r",
      "Routing"
    ]
  },
  {
    "objectID": "routing.html#wrap-up",
    "href": "routing.html#wrap-up",
    "title": "Routing",
    "section": "Wrap up",
    "text": "Wrap up\nIn this tutorial, we explored how to use the r5r package to estimate travel distances and times across multiple transport modes ‚Äî car, walking, cycling, and public transit ‚Äî using a muti-modal network model.\nWe learned to:\n\nLoad and prepare origin‚Äìdestination (OD) data from census units.\nBuild and use an R5 multimodal transport network.\nCompute travel time matrices for different modes and interpret their outputs.\nAdjust routing parameters such as:\n\ndeparture_datetime\nmax_trip_duration\nmax_lts (Level of Traffic Stress)\nmax_rides, mode_egress, and max_walk_time for public transport\n\nExtract detailed itineraries with detailed_itineraries() to understand trip segments, modes, distances, and durations.\nCompare Euclidean and network distances, and compute circuity to quantify the efficiency of different travel modes\n\nFinally, we visualized and aggregated routes using stplanr::overline(), combining spatial and population data to identify segments with potentially higher travel demand.",
    "crumbs": [
      "Home",
      "r5r",
      "Routing"
    ]
  },
  {
    "objectID": "routing.html#stop",
    "href": "routing.html#stop",
    "title": "Routing",
    "section": "Stop",
    "text": "Stop\nr5r objects are still allocated to any amount of memory previously set after they are done with their calculations. In order to remove an existing r5r object and reallocate the memory it had been using, we use the stop_r5 function followed by a call to Java‚Äôs garbage collector, as follows:\n\nr5r::stop_r5(r5r_lisboa)\nrJava::.jgc(R.gc = TRUE)",
    "crumbs": [
      "Home",
      "r5r",
      "Routing"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Modelling of Transport Systems",
    "section": "",
    "text": "This website makes available materials, data and tutorials to use at the Modelling of Transport Systems course of the Master in Transportation Systems at Instituto Superior T√©cnico - University of Lisbon.\n \n\n\n\n\n\n\nThis website is under construction\n\n\n\nIf you have any suggestions, please contact the course teacher."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "To learn more about Quarto websites visit https://quarto.org/docs/websites."
  },
  {
    "objectID": "pois.html",
    "href": "pois.html",
    "title": "POIs and Grids",
    "section": "",
    "text": "Search and download your census data from official sources.\n\nIn Portugal: https://mapas.ine.pt/download/index2021.phtml\n\n\n\n\n\n\n\nFor this exercises, you just need the population associated with a statistical unit, as smaller as possible\n\n\n\n\nlibrary(tidyverse)\nlibrary(sf)\n\ncensus = st_read(\"data/Lisbon/BGRI2021_1106.gpkg\") # census units in polygons\nplot(census$geom)\n\n# from polygons to points\ncensus_poitns = census |&gt; \n  st_transform(4326) |&gt; # make sue it is in universal CRS\n  st_centroid()\nplot(census_poitns) # census units in points\nnames(census_poitns)\n\ncensus_poitns = census_poitns |&gt;\n  select(BGRI2021, N_INDIVIDUOS) |&gt; # only my code area and population\n  rename(id = BGRI2021,\n         residents = N_INDIVIDUOS) # rename variables\nst_write(census_poitns, \"data/census_poitns.gpkg\") # save for later\n\n\n\nCode\nlibrary(mapview)\nmapview(census_poitns) + mapview(census)\n\n\n\n\n\n\n\n\n\nIn the case you don‚Äôt have already a city limit, you can create one based on the ‚Äúdissolve‚Äù of the inner boundaries of your census data, as follows\n\n#dissolve \ncity_limit = census |&gt; st_union() |&gt; st_as_sf()\nplot(city_limit)\n\n\n\n\n\n\n\nNote\n\n\n\nIf you don‚Äôt have census data at a reasonable level (census blocks), you can recreate random points in your city. See the code bellow üîé\n\n\n\n\nGenerate synthetic census-like points for a City\n# 0. Load libraries\nlibrary(sf)\nlibrary(dplyr)\n\n# 1. Read city polygon (replace with your file path)\ncity_limit &lt;- st_read(\"data/city_limit.gpkg\") |&gt; st_transform(4326)\n\n# 2. Set parameters\nset.seed(42) # for reproducibility\ntotal_pop &lt;- 545000 # your city population\navg_residents &lt;- 300 # a census block average\nn_points &lt;- round(total_pop / avg_residents)\n\n# 3. Generate random points within the city boundary\ncensus_syn &lt;- st_sample(city_limit, size = n_points, type = \"random\") |&gt;\n  st_as_sf() |&gt;\n  mutate(id = 1:n_points)\n\n# # 4. Compute distance from city center (for density weighting) - OPTIONAL\n# center &lt;- st_centroid(city_limit)\n# dist_center &lt;- as.numeric(st_distance(census_syn, center))  # in meters\n# \n# # 5. Create weights so closer points get higher population - OPTIONAL\n# # Inverse distance weighting (add +1 to avoid division by zero)\n# weights &lt;- 1 / (dist_center + 1)\n\n# assign random populations that sum to total_pop\nweights &lt;- runif(n_points)\n\n# Normalize weights to sum to 1 and assign residents\nresidents &lt;- round(weights / sum(weights) * total_pop)\n\n# 6. Adjust rounding so the total sums exactly to total_pop\ndiff &lt;- total_pop - sum(residents)\nif (diff != 0) {\n  residents[1:abs(diff)] &lt;- residents[1:abs(diff)] + sign(diff)\n}\n\n# 7. Add residents to points\ncensus_syn$residents &lt;- residents\nsum(census_syn$residents) # should be total_pop\n\n# 8. Quick visualization\nmapview::mapview(census_syn, zcol = \"residents\")\n\n# 9. Save for later\nst_write(census_syn, \"data/synthetic_census_points.gpkg\", delete_dsn = TRUE)",
    "crumbs": [
      "Home",
      "r5r",
      "POIs and Grids"
    ]
  },
  {
    "objectID": "pois.html#census-data",
    "href": "pois.html#census-data",
    "title": "POIs and Grids",
    "section": "",
    "text": "Search and download your census data from official sources.\n\nIn Portugal: https://mapas.ine.pt/download/index2021.phtml\n\n\n\n\n\n\n\nFor this exercises, you just need the population associated with a statistical unit, as smaller as possible\n\n\n\n\nlibrary(tidyverse)\nlibrary(sf)\n\ncensus = st_read(\"data/Lisbon/BGRI2021_1106.gpkg\") # census units in polygons\nplot(census$geom)\n\n# from polygons to points\ncensus_poitns = census |&gt; \n  st_transform(4326) |&gt; # make sue it is in universal CRS\n  st_centroid()\nplot(census_poitns) # census units in points\nnames(census_poitns)\n\ncensus_poitns = census_poitns |&gt;\n  select(BGRI2021, N_INDIVIDUOS) |&gt; # only my code area and population\n  rename(id = BGRI2021,\n         residents = N_INDIVIDUOS) # rename variables\nst_write(census_poitns, \"data/census_poitns.gpkg\") # save for later\n\n\n\nCode\nlibrary(mapview)\nmapview(census_poitns) + mapview(census)\n\n\n\n\n\n\n\n\n\nIn the case you don‚Äôt have already a city limit, you can create one based on the ‚Äúdissolve‚Äù of the inner boundaries of your census data, as follows\n\n#dissolve \ncity_limit = census |&gt; st_union() |&gt; st_as_sf()\nplot(city_limit)\n\n\n\n\n\n\n\nNote\n\n\n\nIf you don‚Äôt have census data at a reasonable level (census blocks), you can recreate random points in your city. See the code bellow üîé\n\n\n\n\nGenerate synthetic census-like points for a City\n# 0. Load libraries\nlibrary(sf)\nlibrary(dplyr)\n\n# 1. Read city polygon (replace with your file path)\ncity_limit &lt;- st_read(\"data/city_limit.gpkg\") |&gt; st_transform(4326)\n\n# 2. Set parameters\nset.seed(42) # for reproducibility\ntotal_pop &lt;- 545000 # your city population\navg_residents &lt;- 300 # a census block average\nn_points &lt;- round(total_pop / avg_residents)\n\n# 3. Generate random points within the city boundary\ncensus_syn &lt;- st_sample(city_limit, size = n_points, type = \"random\") |&gt;\n  st_as_sf() |&gt;\n  mutate(id = 1:n_points)\n\n# # 4. Compute distance from city center (for density weighting) - OPTIONAL\n# center &lt;- st_centroid(city_limit)\n# dist_center &lt;- as.numeric(st_distance(census_syn, center))  # in meters\n# \n# # 5. Create weights so closer points get higher population - OPTIONAL\n# # Inverse distance weighting (add +1 to avoid division by zero)\n# weights &lt;- 1 / (dist_center + 1)\n\n# assign random populations that sum to total_pop\nweights &lt;- runif(n_points)\n\n# Normalize weights to sum to 1 and assign residents\nresidents &lt;- round(weights / sum(weights) * total_pop)\n\n# 6. Adjust rounding so the total sums exactly to total_pop\ndiff &lt;- total_pop - sum(residents)\nif (diff != 0) {\n  residents[1:abs(diff)] &lt;- residents[1:abs(diff)] + sign(diff)\n}\n\n# 7. Add residents to points\ncensus_syn$residents &lt;- residents\nsum(census_syn$residents) # should be total_pop\n\n# 8. Quick visualization\nmapview::mapview(census_syn, zcol = \"residents\")\n\n# 9. Save for later\nst_write(census_syn, \"data/synthetic_census_points.gpkg\", delete_dsn = TRUE)",
    "crumbs": [
      "Home",
      "r5r",
      "POIs and Grids"
    ]
  },
  {
    "objectID": "pois.html#points-of-interest",
    "href": "pois.html#points-of-interest",
    "title": "POIs and Grids",
    "section": "Points of Interest",
    "text": "Points of Interest\n\nOpenStreetMap\nFrom OSM we can export several different opportunities to use on routing and accessibility exercises.\nFor instance, the 15-min city idea follows the Flowers of Proximity, to categorize the opportinities in 7 different categories, based on B√ºttner et al. (2022).\n\n\n\n\n\n\n\nThe Flowers of Proximity\n\n\nFor the Streets4All project, and SiteSelection package (Rosa F√©lix and Gabriel Valen√ßa 2024), we divided in:\n\nAmenities\nHealthcare\nLeisure\nShop\nSport\nTourism\n\n\n\nHot export tool\nUsing the HOT Export Tool, you can select a few categories, and export as .gpkg or .geojson.\n\n\n\n\n\n\nSelect 6 to 8 categories\n\n\n\nFor instance: schools, hospitals, ATMs, parks, supermarkets, and restaurants.\n\n\nYour further analysis will be made by comparing the categories you selected and exported.\n\nDealing with points and polygons from OSM\nIf your export brings both polygons and points, you should convert the polygons to points (centroids).\n\npois_raw = st_read(\"data/pois.gpkg\") # downloaded from HOT export\n\npois_cat = pois_raw |&gt; \n  mutate(type = case_when(\n      !is.na(shop) & shop %in% c(\"supermarket\", \"convenience\") ~ \"grocery\",\n      amenity == \"marketplace\" ~ \"grocery\",\n      !is.na(leisure) ~ leisure,\n      amenity %in% c(\"restaurant\", \"pub\", \"cafe\", \"bar\", \"fast_food\") ~ \"restaurant\",\n      TRUE ~ amenity\n    )) |&gt; \n  select(osm_id, type, name)\n\ntable(pois_cat$type)\n\n       atm    grocery   hospital       park restaurant     school \n       316        799         42        503       4956        445 \n\n# separate points form polygons\npois_points = pois_cat |&gt; st_collection_extract(\"POINT\")\npois_polygons = pois_cat |&gt;  st_collection_extract(\"POLYGON\")\n\n# transform polygons in points\npois_polygons = st_centroid(pois_polygons)\n\n# bind them\npois = bind_rows(pois_points, pois_polygons)\n\nmapview(pois, zcol = \"type\")\n\n\n\n\n\n\n\n\nGeometric filter\nTo keep only the POIs relative to your city limit, you can make a geometrical filter, as:\n\npois = pois[city_limit,]\n\n# export for later\nst_write(pois, \"data/Lisbon/pois_osm_points.gpkg\", delete_dsn = TRUE)\n\n\n\n\nScript\nA more flexible approach to download the data, but requires more codding üßë‚Äçüíª\n\n\n\n\n\n\nSee the script we did for all Portugal, and the dataset for Lisbon (2024): data_extract.R (line 146)\n\n\n\nYou can explore other OpenStreetMap categories at their Wiki.",
    "crumbs": [
      "Home",
      "r5r",
      "POIs and Grids"
    ]
  },
  {
    "objectID": "pois.html#grids",
    "href": "pois.html#grids",
    "title": "POIs and Grids",
    "section": "Grids",
    "text": "Grids\nYou may want to use the original census units, or create a squared oh hexagonal grid.\n\nCreate a grid\nMatch all the Census and POIs to that grid\n\n\nCreate a grid\nWe will use the city of Lisbon as example\n\nlibrary(sf)\nlibrary(tidyverse)\nlibrary(mapview)\n\ncity_limit = st_read(\"data/Lisbon/Lisboa_lim.gpkg\")\nplot(city_limit)\n\n\n\n\n\n\n\nHexagonal using h3jsr\nMake an hexagonal grid that covers the city polygon, using the universal H3 grid.\n\nlibrary(h3jsr)\n\n# Resolution: https://h3geo.org/docs/core-library/restable/ \n# h3_res = 10 # 150m diameter\nh3_res = 9 # 400m diameter\n# h3_res = 8 # 1060m diameter\n\nGRID_h3 = city_limit |&gt;  \n  polygon_to_cells(res = h3_res, simple = FALSE)\nGRID_h3 = GRID_h3$h3_addresses |&gt;\n  cell_to_polygon(simple = FALSE)\nGRID_h3 = GRID_h3 |&gt;\n  mutate(id = seq(1:nrow(GRID_h3)))  # give an ID to each cell\nh3_index = GRID_h3 |&gt; st_drop_geometry() # save h3_address for later\n\nmapview(GRID_h3)\n\n\n\n\nThe color is only referent to the id\n\n\n\n\nSquared\nMake a squared grid that covers the city polygon\n\nGRID = city_limit |&gt;\n  st_transform(crs = 3857) |&gt; # to a projected crs\n  st_make_grid(cellsize = 400, # meters, we are using a projected crs\n               what = \"polygons\",\n               square = TRUE) |&gt; # if FALSE, hexagons\n  st_sf() |&gt; # from list to sf\n  st_transform(crs = 4326) |&gt;  # back to WGS84\n  st_intersection(city_limit$geom) # crop (optional)\n\nGRID = GRID |&gt;  \n  rename(geometry = st_make_grid.st_transform.city_limit..crs...3857...cellsize...400..) |&gt; \n  mutate(id = c(1:nrow(GRID))) # just to give an ID to each cell \n  \nmapview(GRID, alpha.regions = 0.2)\n\n\n\n\nThe color is only referent to the id\n\n\n\n\n\n\n\n\nTip\n\n\n\nYou should stick with just one of them: squares or hexagons.\n\n\n\n\n\nAreas with information\nNow, we can associate these areas (and their centroids) with all the information we want.\n\nWith POIs\n\n# Points of interest from script\nPOIs = st_read(\"https://github.com/U-Shift/Traffic-Simulation-Models/releases/download/2025/pois_osm_points.gpkg\")\n\n\n\n\nCode for squares\n# count points by type in areas\nGRID_pois = POIs |&gt; st_join(GRID, join = st_within)\n\ncounts_type = GRID_pois |&gt;\n     st_drop_geometry() |&gt;   # drop geometry for counting\n     group_by(id, type) |&gt;\n     summarise(n = n(), .groups = \"drop\") |&gt;\n     tidyr::pivot_wider(names_from = type, values_from = n, values_fill = 0)\n\nGRID_pois = GRID |&gt;\n  left_join(counts_type, by = \"id\") |&gt;\n  mutate(across(where(is.numeric), ~replace_na(.x, 0)))\n\nmapview(GRID_pois, zcol = \"restaurant\") # for instance\n\n\n\nThe result is a grid with too many columns (one for each type). Consider using only the group.\n\n\nWith Census\n\n# Census data\ncensus = st_read(\"https://github.com/U-Shift/Traffic-Simulation-Models/releases/download/2025/Censos_Lx.gpkg\")\n\n# count points by type in areas\nGRID_census = census |&gt; st_join(GRID, join = st_within)\n\ncensus_density = GRID_census |&gt;\n  st_drop_geometry() |&gt;   # drop geometry for counting\n  group_by(id.y) |&gt;\n  summarise(buildings = sum(buildings),\n            families = sum(families),\n            residents = sum(residents)) |&gt; \n  rename(id = id.y) |&gt; \n  filter(!is.na(id))\n\nGRID_census = GRID |&gt;\n  left_join(census_density, by = \"id\") |&gt;\n  mutate(across(where(is.numeric), ~replace_na(.x, 0)))\n\nmapview(GRID_census, zcol = \"residents\")\n\n\n\n\nAll together\n\nGRID_data = GRID_census |&gt; left_join(GRID_pois |&gt; st_drop_geometry())\n\nThe same for Hex grid\n\n\nCode for Hexagons\n# POIs\nGRIDhex_pois = POIs |&gt; st_join(GRID_h3, join = st_within)\n\ncounts_type = GRIDhex_pois |&gt;\n     st_drop_geometry() |&gt;   # drop geometry for counting\n     group_by(id, type) |&gt;\n     summarise(n = n(), .groups = \"drop\") |&gt;\n     tidyr::pivot_wider(names_from = type, values_from = n, values_fill = 0)\n\nGRIDhex_pois = GRID_h3 |&gt;\n  left_join(counts_type, by = \"id\") |&gt;\n  mutate(across(where(is.numeric), ~replace_na(.x, 0)))\n\n#  Census\nGRIDhex_census = census |&gt; st_join(GRID_h3, join = st_within)\n\ncensus_density = GRIDhex_census |&gt;\n  st_drop_geometry() |&gt;   # drop geometry for counting\n  group_by(id.y) |&gt;\n  summarise(buildings = sum(buildings),\n            families = sum(families),\n            residents = sum(residents)) |&gt; \n  rename(id = id.y) |&gt; \n  filter(!is.na(id))\n\nGRIDhex_census = GRID_h3 |&gt;\n  left_join(census_density, by = \"id\") |&gt;\n  mutate(across(where(is.numeric), ~replace_na(.x, 0)))\n\n# All together now\nGRIDhex_data = GRIDhex_census |&gt; left_join(GRIDhex_pois |&gt; st_drop_geometry())\n\nmapview(GRIDhex_data, zcol = \"residents\")",
    "crumbs": [
      "Home",
      "r5r",
      "POIs and Grids"
    ]
  },
  {
    "objectID": "pois.html#centroid-coordinates",
    "href": "pois.html#centroid-coordinates",
    "title": "POIs and Grids",
    "section": "Centroid coordinates",
    "text": "Centroid coordinates\nWe may want to have this information as points, for instance for routing to opportunities.\n\n# hexagons\nPOINTShex = GRIDhex_data |&gt; \n  st_centroid()\nGRIDhex_data = GRIDhex_data |&gt; \n  mutate(lon = st_coordinates(POINTShex)[,1],\n         lat = st_coordinates(POINTShex)[,2])\n\n# squares\nPOINTSsq = GRID_data |&gt; \n  st_centroid()\nGRID_data = GRID_data |&gt; \n  mutate(lon = st_coordinates(POINTSsq)[,1],\n         lat = st_coordinates(POINTSsq)[,2])\n\n\n\n\n\n\n\nTip\n\n\n\nDon‚Äôt forget to save your data, this will be very useful for the next exercises.\n\n\n\nsaveRDS(GRID_data, \"data/Lisbon/GRIDsq_data.rds\")\nsaveRDS(GRIDhex_data, \"data/Lisbon/GRIDhex_data.rds\")",
    "crumbs": [
      "Home",
      "r5r",
      "POIs and Grids"
    ]
  },
  {
    "objectID": "rr5r.html",
    "href": "rr5r.html",
    "title": "R, RStudio and r5r",
    "section": "",
    "text": "In this chapter we will guide you through the installation of R, RStudio and the packages you will need for this course, for the macro network models.\nR and RStudio1 are separate downloads.\n\n\nYou will need R installed on your computer. R stats (how it is also known) is a programming language and free software environment for statistical computing and graphics supported by the R Foundation for Statistical Computing.\nThe download links live at The Comprehensive R Archive Network (aka CRAN). The most recent version is 4.5.1, but you can use &gt;= 4.1.x if you already have it installed.\n\nWindowsMacUbuntu\n\n\nDownload R-4.5.1 for Windows and run the executable file.\n\n\n\n\n\n\nImportant\n\n\n\nYou will also need to install Rtools, which is a collection of tools necessary to build R packages in Windows.\n\n\n\n\nDownload R-4.5.1 for MacOX. You will have to choose between the arm64 or the x86-64 version.\nDownload the .pkg file and install it as usual.\n\n\n\nThese are instructions for Ubuntu. If you use other linux distribution, please follow the instructions on The Comprehensive R Archive Network - CRAN.\n\nYou can look for R in the Ubuntu Software Center or install it via the terminal:\n\n# sudo apt update && sudo apt upgrade -y\nsudo apt install r-base\n\nOr, if you prefer, you can install the latest version of R from CRAN:\n\n# update indices\nsudo apt update -qq\n# install two helper packages we need\nsudo apt install --no-install-recommends software-properties-common dirmngr\n# add the signing key (by Michael Rutter) for these repos\nwget -qO- https://cloud.r-project.org/bin/linux/ubuntu/marutter_pubkey.asc | sudo tee -a /etc/apt/trusted.gpg.d/cran_ubuntu_key.asc\n# add the R 4.0 repo from CRAN -- adjust 'focal' to 'groovy' or 'bionic' as needed\nsudo add-apt-repository \"deb https://cloud.r-project.org/bin/linux/ubuntu $(lsb_release -cs)-cran40/\"\n\nThen run:\n\nsudo apt install r-base r-base-core r-recommended r-base-dev\n\n[Optional] To keep up-to-date r version and packages, you can follow the instructions at r2u\n\n\n\nAfter this installation, you don‚Äôt need to open R base. Please proceed to install RStudio.\n\n\n\nRStudio Desktop is an integrated development environment (IDE) for R. It includes a console, syntax-highlighting editor that supports direct code execution, as well as tools for plotting, history, debugging and workspace management.\nRStudio is available for free download from Posit RStudio.\n\nWindows 10/11MacOSUbuntu\n\n\nDownload RStudio 2025.09 and run the executable file.\n\n\nDownload RStudio 2025.09 and install it as usual.\n\n\n\nThese are instructions for Ubuntu 24. If you use other linux distribution, please follow the instructions on Posit RStudio.\n\nInstall it via the terminal:\n\nsudo apt install libssl-dev libclang-dev\nwget https://download1.rstudio.org/electron/jammy/amd64/rstudio-2025.09.0-387-amd64.deb\nsudo dpkg -i rstudio*\nrm -v rstudio*\n\n\n\n\n\n\n\nYou will need to install some packages to work with the data and scripts in this course.\nYou can install them in RStudio by searching for them in the Packages tab:\n\nor by running the following code in the console:\n\ninstall.packages(\"tidyverse\")\n\ninstall.packages(\"sf\")\ninstall.packages(\"mapview\")\ninstall.packages(\"osmextract\")\ninstall.packages(\"elevatr\")\ninstall.packages(\"stplanr\")\ninstall.packages(\"h3jsr\")\ninstall.packages(\"od\")\n\ninstall.packages(c(\"remotes\", \"devtools\", \"usethis\")) # optional\n\n\n\n\nThe simplest way to install r5r is by running the code below on RStudio Console. This might take a few minutes if this is the first time you install these packages.\n\npkgs = c(\"r5r\", \"accessibility\", \"rJavaEnv\", \"interp\", \"quantreg\")\n\ninstall.packages(pkgs)\n\n# dev version with latest features - optional\nutils::remove.packages('r5r')\ndevtools::install_github(\"ipeaGIT/r5r\", subdir = \"r-package\")\n\n\n\nTo use the {r5r} package (version v2.0 or higher), you will need to have Java Development Kit (JDK) 21 installed on your computer. There are numerous open-source JDK implementations. The easiest way to install JDK is using the new {rJavaEnv} package in R.\n\n# check version of Java currently installed (if any) \nrJavaEnv::java_check_version_rjava()\n\n## if this is the first time you use {rJavaEnv}, you might need to run this code\n## below to consent the installation of Java.\n# rJavaEnv::rje_consent(provided = TRUE)\n\n# install Java 21\nrJavaEnv::java_quick_install(version = 21)\n\n# check if Java was successfully installed\nrJavaEnv::java_check_version_rjava()\n\nAlternatively, you can manually download and install JDK 21.\n\nWindows and MacOSUbuntu\n\n\nGo to Java Development Kit 21, download the latest 21 build corresponding to your operating system and run the executable file.\n\n\nInstall it via the terminal:\n\nsudo apt install -y openjdk-21-jdk openjdk-21-jre\njava -version",
    "crumbs": [
      "Home",
      "Software",
      "R & r5r"
    ]
  },
  {
    "objectID": "rr5r.html#r",
    "href": "rr5r.html#r",
    "title": "R, RStudio and r5r",
    "section": "",
    "text": "You will need R installed on your computer. R stats (how it is also known) is a programming language and free software environment for statistical computing and graphics supported by the R Foundation for Statistical Computing.\nThe download links live at The Comprehensive R Archive Network (aka CRAN). The most recent version is 4.5.1, but you can use &gt;= 4.1.x if you already have it installed.\n\nWindowsMacUbuntu\n\n\nDownload R-4.5.1 for Windows and run the executable file.\n\n\n\n\n\n\nImportant\n\n\n\nYou will also need to install Rtools, which is a collection of tools necessary to build R packages in Windows.\n\n\n\n\nDownload R-4.5.1 for MacOX. You will have to choose between the arm64 or the x86-64 version.\nDownload the .pkg file and install it as usual.\n\n\n\nThese are instructions for Ubuntu. If you use other linux distribution, please follow the instructions on The Comprehensive R Archive Network - CRAN.\n\nYou can look for R in the Ubuntu Software Center or install it via the terminal:\n\n# sudo apt update && sudo apt upgrade -y\nsudo apt install r-base\n\nOr, if you prefer, you can install the latest version of R from CRAN:\n\n# update indices\nsudo apt update -qq\n# install two helper packages we need\nsudo apt install --no-install-recommends software-properties-common dirmngr\n# add the signing key (by Michael Rutter) for these repos\nwget -qO- https://cloud.r-project.org/bin/linux/ubuntu/marutter_pubkey.asc | sudo tee -a /etc/apt/trusted.gpg.d/cran_ubuntu_key.asc\n# add the R 4.0 repo from CRAN -- adjust 'focal' to 'groovy' or 'bionic' as needed\nsudo add-apt-repository \"deb https://cloud.r-project.org/bin/linux/ubuntu $(lsb_release -cs)-cran40/\"\n\nThen run:\n\nsudo apt install r-base r-base-core r-recommended r-base-dev\n\n[Optional] To keep up-to-date r version and packages, you can follow the instructions at r2u\n\n\n\nAfter this installation, you don‚Äôt need to open R base. Please proceed to install RStudio.",
    "crumbs": [
      "Home",
      "Software",
      "R & r5r"
    ]
  },
  {
    "objectID": "rr5r.html#rstudio",
    "href": "rr5r.html#rstudio",
    "title": "R, RStudio and r5r",
    "section": "",
    "text": "RStudio Desktop is an integrated development environment (IDE) for R. It includes a console, syntax-highlighting editor that supports direct code execution, as well as tools for plotting, history, debugging and workspace management.\nRStudio is available for free download from Posit RStudio.\n\nWindows 10/11MacOSUbuntu\n\n\nDownload RStudio 2025.09 and run the executable file.\n\n\nDownload RStudio 2025.09 and install it as usual.\n\n\n\nThese are instructions for Ubuntu 24. If you use other linux distribution, please follow the instructions on Posit RStudio.\n\nInstall it via the terminal:\n\nsudo apt install libssl-dev libclang-dev\nwget https://download1.rstudio.org/electron/jammy/amd64/rstudio-2025.09.0-387-amd64.deb\nsudo dpkg -i rstudio*\nrm -v rstudio*",
    "crumbs": [
      "Home",
      "Software",
      "R & r5r"
    ]
  },
  {
    "objectID": "rr5r.html#r-packages",
    "href": "rr5r.html#r-packages",
    "title": "R, RStudio and r5r",
    "section": "",
    "text": "You will need to install some packages to work with the data and scripts in this course.\nYou can install them in RStudio by searching for them in the Packages tab:\n\nor by running the following code in the console:\n\ninstall.packages(\"tidyverse\")\n\ninstall.packages(\"sf\")\ninstall.packages(\"mapview\")\ninstall.packages(\"osmextract\")\ninstall.packages(\"elevatr\")\ninstall.packages(\"stplanr\")\ninstall.packages(\"h3jsr\")\ninstall.packages(\"od\")\n\ninstall.packages(c(\"remotes\", \"devtools\", \"usethis\")) # optional",
    "crumbs": [
      "Home",
      "Software",
      "R & r5r"
    ]
  },
  {
    "objectID": "rr5r.html#r5r",
    "href": "rr5r.html#r5r",
    "title": "R, RStudio and r5r",
    "section": "",
    "text": "The simplest way to install r5r is by running the code below on RStudio Console. This might take a few minutes if this is the first time you install these packages.\n\npkgs = c(\"r5r\", \"accessibility\", \"rJavaEnv\", \"interp\", \"quantreg\")\n\ninstall.packages(pkgs)\n\n# dev version with latest features - optional\nutils::remove.packages('r5r')\ndevtools::install_github(\"ipeaGIT/r5r\", subdir = \"r-package\")\n\n\n\nTo use the {r5r} package (version v2.0 or higher), you will need to have Java Development Kit (JDK) 21 installed on your computer. There are numerous open-source JDK implementations. The easiest way to install JDK is using the new {rJavaEnv} package in R.\n\n# check version of Java currently installed (if any) \nrJavaEnv::java_check_version_rjava()\n\n## if this is the first time you use {rJavaEnv}, you might need to run this code\n## below to consent the installation of Java.\n# rJavaEnv::rje_consent(provided = TRUE)\n\n# install Java 21\nrJavaEnv::java_quick_install(version = 21)\n\n# check if Java was successfully installed\nrJavaEnv::java_check_version_rjava()\n\nAlternatively, you can manually download and install JDK 21.\n\nWindows and MacOSUbuntu\n\n\nGo to Java Development Kit 21, download the latest 21 build corresponding to your operating system and run the executable file.\n\n\nInstall it via the terminal:\n\nsudo apt install -y openjdk-21-jdk openjdk-21-jre\njava -version",
    "crumbs": [
      "Home",
      "Software",
      "R & r5r"
    ]
  },
  {
    "objectID": "rr5r.html#footnotes",
    "href": "rr5r.html#footnotes",
    "title": "R, RStudio and r5r",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nWe will use RStudio, although if you already use other studio such as VScode, that‚Äôs also fine.‚Ü©Ô∏é",
    "crumbs": [
      "Home",
      "Software",
      "R & r5r"
    ]
  },
  {
    "objectID": "pareto.html",
    "href": "pareto.html",
    "title": "Pareto frontier",
    "section": "",
    "text": "See the r5r vignettes ‚ÄúAccounting for monetary costs‚Äù and ‚ÄúTrade-offs between travel time and monetary cost‚Äù (Pereira et al. 2021)",
    "crumbs": [
      "Home",
      "r5r",
      "Pareto frontier"
    ]
  },
  {
    "objectID": "pareto.html#create-rules-for-an-operator",
    "href": "pareto.html#create-rules-for-an-operator",
    "title": "Pareto frontier",
    "section": "Create rules for an operator",
    "text": "Create rules for an operator\nIn this case, I am creating random rules for fares, considering the mode, the transfers, and changing between modes.\n\n# create basic fare structure\nfare_structure &lt;- setup_fare_structure(r5r_lisboa, \n                                       base_fare = 1.65,\n                                       by = \"MODE\")\n\n# update the cost of bus and subway fares\nfare_structure$fares_per_type &lt;- fare_structure$fares_per_type |&gt; \n  mutate(fare = case_when(\n    type == \"BUS\"    ~ 1.65,\n    type == \"SUBWAY\" ~ 2.00, # imagine it is more expensive\n    TRUE             ~ fare   # keep existing fare if no condition matches\n  ))\n\n# update the cost of transfers\nfare_structure$fares_per_transfer &lt;- fare_structure$fares_per_transfer |&gt; \n  mutate(fare = case_when(\n    first_leg == \"BUS\" & second_leg == \"BUS\" ~ 2.80, # extra cost for 2 trips\n      first_leg == \"SUBWAY\" & second_leg == \"SUBWAY\" ~ 2.00, # no extra cost\n    first_leg != second_leg                  ~ 3.50,\n    TRUE                                     ~ fare\n  ))\n\n\n# update transfer_time_allowance to 60 minutes\nfare_structure$transfer_time_allowance &lt;- 60\n\nfare_structure$fares_per_type = fare_structure$fares_per_type |&gt;\n  mutate(\n    unlimited_transfers = if_else(type == \"SUBWAY\", TRUE, unlimited_transfers),\n    allow_same_route_transfer = if_else(type == \"SUBWAY\", TRUE, allow_same_route_transfer)\n  )\n\n# save fare rules to temp file\n# r5r::write_fare_structure(fare_structure, file_path = \"data/Lisbon/fares_lisbon.zip\")\n# fare_structure &lt;- r5r::read_fare_structure(\"data/Lisbon/fares_lisbon.zip\")",
    "crumbs": [
      "Home",
      "r5r",
      "Pareto frontier"
    ]
  },
  {
    "objectID": "pareto.html#calculating-a-pareto_frontier",
    "href": "pareto.html#calculating-a-pareto_frontier",
    "title": "Pareto frontier",
    "section": "Calculating a pareto_frontier()",
    "text": "Calculating a pareto_frontier()\nIn this example, we calculate the Pareto frontier from all origins to downtown (Baixa) considering multiple cutoffs of monetary costs:\n\n‚Ç¨1, which would only allow for walking trips\n‚Ç¨1.65, which would only allow for bus trips\n‚Ç¨2.00, which would allow for a single or multiple subway trips\n‚Ç¨2.80, which would allow for bus + bus\n‚Ç¨3.50, which would allow for walking + bus + subway\n\n\ndeparture_datetime &lt;- as.POSIXct(\"01-10-2025 10:00:00\", \n                                 format = \"%d-%m-%Y %H:%M:%S\")\n\nprtf &lt;- pareto_frontier(\n  r5r_lisboa,\n  origins = POINTS,\n  destinations = BAIXA,\n  mode = c(\"WALK\", \"TRANSIT\"),\n  departure_datetime = departure_datetime,\n  fare_structure = fare_structure,\n  fare_cutoffs = c(1, 1.65, 2.0, 2.8, 3.5),\n  progress = TRUE\n  )\n\n\n\nCode\n# select some origin and destinations\npf2 &lt;- prtf |&gt; filter(from_id %in% c(\"727\", \"1979\", \"772\"))\n\n# recode modes \npf2 &lt;- pf2 |&gt;\n  mutate(\n    modes = case_when(\n      monetary_cost == 1    ~ \"Walk\",\n      monetary_cost == 1.65 ~ \"Bus\",\n      monetary_cost == 2.0  ~ \"Subway\",\n      monetary_cost == 2.80  ~ \"Bus + Bus\",\n      monetary_cost == 3.5  ~ \"Bus + Subway\"\n      # TRUE                  ~ \"Bus\"\n    )\n  )\n\n\n\n\n\n\n\nAn optimum route alternative means that one cannot make a faster trip without increasing costs, and one cannot make a cheaper trip without increasing travel time.\n\n# calculate travel times function\ncalculate_travel_times &lt;- function(fare) {\n  ttm_df &lt;- travel_time_matrix(\n    r5r_lisboa,\n    origins = POINTShex,\n    destinations = BAIXA,\n    mode = c(\"WALK\", \"TRANSIT\"),\n    departure_datetime = departure_datetime,\n    time_window = 1,\n    fare_structure = fare_structure,\n    max_fare = fare,\n    max_trip_duration = 60,\n    max_walk_time = 15\n  )\n\n  return(ttm_df)\n}\n\n\n# calculate travel times, and combine results\nttm &lt;- calculate_travel_times(fare = Inf) # no budget restriction\nttm_200 &lt;- calculate_travel_times(fare = 2) # 2 euro\n\n# merge results\nttm &lt;- ttm |&gt;\n  left_join(\n    ttm_200 |&gt; select(from_id, to_id, travel_time_p50),\n    by = c(\"from_id\", \"to_id\"),\n    suffix = c(\"\", \"_200\")\n  ) |&gt;\n  mutate(\n    travel_time_200 = travel_time_p50_200,\n    travel_time_unl = travel_time_p50\n  ) |&gt;\n  select(-travel_time_p50, -travel_time_p50_200)\n\n\ntail(ttm, 10)\n\n\n\nCode\n# plot of overall travel time differences between limited and unlimited cost travel time matrices \ntime_difference &lt;- ttm %&gt;%\n  filter(!is.na(travel_time_200)) %&gt;%\n  group_by(travel_time_unl, travel_time_200) %&gt;%\n  summarise(count = n(), .groups = \"drop\")\n\np1 &lt;- ggplot(time_difference, aes(y = travel_time_unl, x = travel_time_200)) +\n  geom_point(size = 0.7) +\n  coord_fixed() +\n  scale_x_continuous(breaks = seq(0, 45, 5)) +\n  scale_y_continuous(breaks = seq(0, 45, 5)) +\n  theme_light() +\n  theme(legend.position = \"none\") +\n  labs(y = \"travel time (minutes)\\nunestricted monetary cost\",\n       x = \"travel time (minutes)\\nmonetary cost restricted to EUR 2.00\"\n       )\n\n# plot of unreachable destinations when the monetary cost limit is too low\nunreachable &lt;- ttm %&gt;%\n  group_by(travel_time_unl, missing = is.na(travel_time_200)) %&gt;%\n  summarise(count = n(), .groups = \"drop_last\") %&gt;%   # keep grouping by travel_time_unl\n  mutate(perc = count / sum(count, na.rm = TRUE)) %&gt;%\n  ungroup() %&gt;%\n  filter(missing) %&gt;%          # keep only rows where travel_time_200 was NA\n  tidyr::drop_na()\n\np2 &lt;- ggplot(unreachable, aes(x=travel_time_unl, y=perc)) +\n  geom_col() +\n  coord_flip() +\n  scale_x_continuous(breaks = seq(0, 60, 5)) +\n  scale_y_continuous(limits = c(0, 1), breaks = seq(0, 1, 0.2), \n                     labels = paste0(seq(0, 100, 20), \"%\")) +\n  theme_light() +\n  labs(x = \"travel time (minutes)\\nwithout monetary cost restriction\",\n       y = \"% of unreachable destinations\\nconsidering a eur 2.00 monetary cost limit\")",
    "crumbs": [
      "Home",
      "r5r",
      "Pareto frontier"
    ]
  },
  {
    "objectID": "pareto.html#calculating-accessibility-with-monetary-cost",
    "href": "pareto.html#calculating-accessibility-with-monetary-cost",
    "title": "Pareto frontier",
    "section": "Calculating accessibility with monetary cost",
    "text": "Calculating accessibility with monetary cost\nTo Healthcare facilities\n\nGRID_data = readRDS(\"data/Lisbon/GRIDhex_data.rds\")\nGRID_df = GRID_data |&gt; st_drop_geometry()\n\n\n# calculate accessibility function\ncalculate_accessibility &lt;- function(fare, fare_string) {\n  access_df &lt;- accessibility(\n    r5r_lisboa,\n    origins = GRID_df,\n    destinations = GRID_df,\n    mode = c(\"WALK\", \"TRANSIT\"),\n    departure_datetime = departure_datetime,\n    time_window = 1,\n    opportunities_colname = \"healthcare\",\n    cutoffs = 40,\n    fare_structure = fare_structure,\n    max_fare = fare,\n    max_trip_duration = 60,\n    max_walk_time = 15,\n    progress = FALSE)\n\n  access_df$max_fare &lt;- fare_string\n\n  return(access_df)\n}\n\n# calculate accessibility, combine results, and convert to SF\naccess_165 &lt;- calculate_accessibility(fare=1.65, fare_string=\"EUR 1.65 budget\")\naccess_unl &lt;- calculate_accessibility(fare=Inf, fare_string=\"Unlimited budget\")\n\naccess &lt;- rbind(access_165, access_unl)\n\n# bring geometry\naccess = access |&gt; \n  left_join(GRID_df |&gt;\n              select(id, h3_address) |&gt;\n              mutate(id = as.character(id)))\naccess$geometry = h3jsr::cell_to_polygon(access$h3_address)\naccess &lt;- st_as_sf(access)\n\n\n\nCode\n# plot accessibility maps\nggplot(data = access) +\n  geom_sf(aes(fill = accessibility), color=NA, size = 0.2) +\n  scale_fill_distiller(palette = \"Spectral\") +\n  facet_wrap(~max_fare) +\n  labs(subtitle = \"Effect of monetary cost on accessibility\") +\n  theme_minimal() +\n  theme(legend.position = \"bottom\",\n        axis.text = element_blank())\n\n\n\n\n\n\nWith census units\n\n\n\n\n\n\n\n\nReading suggestion\n\n\n\nThe impact of transit monetary costs on transport inequality (Herszenhut et al. 2022)\nThe cost of equity: Assessing transit accessibility and social disparity using total travel cost (El-Geneidy et al. 2016)",
    "crumbs": [
      "Home",
      "r5r",
      "Pareto frontier"
    ]
  },
  {
    "objectID": "network.html",
    "href": "network.html",
    "title": "Network setup",
    "section": "",
    "text": "In this chapter we will guide you through the data requirements, data collection, and setting up a multi-modal network with r5r.",
    "crumbs": [
      "Home",
      "r5r",
      "Network setup"
    ]
  },
  {
    "objectID": "network.html#data-requirements",
    "href": "network.html#data-requirements",
    "title": "Network setup",
    "section": "Data requirements",
    "text": "Data requirements\nYou will need R and r5r (Pereira et al. 2021) package installed on your computer.\nr5r sets-up a network file .dat by combining the following datasets in the same folder:\n\nRoad Network (OpenStreetMap1 as .osm.pbf)\nGTFS2 from PTransit operators (a single .zip or several)\nDigital Elevation Model3 (.tif), to consider impedances for walking and cycling\n\nFor the documentation of data needed, see r5r::build_network",
    "crumbs": [
      "Home",
      "r5r",
      "Network setup"
    ]
  },
  {
    "objectID": "network.html#road-networks",
    "href": "network.html#road-networks",
    "title": "Network setup",
    "section": "Road Networks",
    "text": "Road Networks\n\nOpenStreetMap\nThe OpenStreetMap is a collaborative online mapping project that creates a free editable map of the world.\nThis is the most used source of road network data for transportation analysis in academia, since it is available almost everywhere in the world, is open and free to use.\n\n\n\n\n\n\nAlthough it can be not 100% accurate, OSM is a good source of data for most of the cases.\n\n\n\nYou can access it‚Äôs visualization tool at www.openstreetmap.org. To edit the map, you can use the Editor, once you register.\nIf you want to download the data, you can use the following tools.\n\nOverpass API\nGeofabrik\n\nThese websites include all the OSM data, with much more information than you need.\n\n\nHOT Export Tool\nThis interactive tool helps you to select the region you want to extract (or import an existing city_limit.geojson4), the type of information to include, and the output data format.\nAccess via export.hotosm.org5. Select format as .gpkg and .pbf.\n\n\nAfter the export, you can read in R using the sf package:\n\n# load osm export in .gpkg\nroad_network = sf::st_read(\"data/Lisbon/Lisbon_road_network.gpkg\", quiet = TRUE)\n\n# filter main roads\nroad_network_base = road_network |&gt;\n  filter(highway %in% c(\"primary\", \"secondary\", \"tertiary\", \"trunk\", \"motorway\")) |&gt; \n  select(osm_id, name, highway)\n\n# map\nmapview::mapview(road_network_base, zcol = \"highway\")\n\n\n\n\n\n\n\n\nOSM in R\nThere are also some R packages that can help you to download and work with OpenStreetMap data, such as:\n\nosmdata\nosmextract\n\nThis is an example of how to download OpenStreetMap road network data using the osmextract package:\n\nlibrary(osmextract)\nOSM_Malta = oe_get_network(place = \"Malta\") # it will geocode the place\n\nMalta_main_roads = OSM_Malta |&gt; \n  filter(highway %in% c(\"primary\", \"secondary\", \"tertiary\", \"trunk\"))\n\nplot(Malta_main_roads[\"highway\"])",
    "crumbs": [
      "Home",
      "r5r",
      "Network setup"
    ]
  },
  {
    "objectID": "network.html#gtfs---transportation-services-data",
    "href": "network.html#gtfs---transportation-services-data",
    "title": "Network setup",
    "section": "GTFS - Transportation Services‚Äô Data",
    "text": "GTFS - Transportation Services‚Äô Data\nGeneral Transit Feed Specification (GTFS) is standard format for documenting public transportation information, including: routes, schedules, stop locations, calendar patterns, trips, and possible transfers. Transit agencies are responsible for maintaining the data up-to-date.\nThis information is used in several applications, such as Google Maps, to provide public transportation directions. It can be offered for a city, a region, or even a whole country, depending on the PT agency.\nThe recent version 2 of the GTFS standard includes more information, such as real-time data.\nThe data is usually in a .zip file that includes several .txt files (one for each type of information) with tabular relations.\n\n\n\nSource: trilliumtransit.com\n\n\n\nOnline sources\nYou can find most GTFS data in the following websites:\n\nTransitLand\nMobility Database\n\nSome PT agencies also provide their open-data in their websites.\n\n\nNational Access Points\nThe European Union has a directive that requires the member states to provide access to transportation data. Data includes not only Public Transportation data, but also road networks, car parking, and other transportation-related information.\nList of the European Union members states with National Access Points for Transportation data\nExample of Bus services data in Belgium:\n\n\n\nSource: Transport Data Belgium\n\n\n\n\nR packages\nThere are some nice R packages to read and manipulate GTFS data, such as:\n\ntidytransit\ngtfstools\nGTFShift\n\n\n\n\n\n\n\nBe aware that they may share the same function names, so it is important to use of of them at the time.\n\n\n\n\nCreate shapes.txt\nSome operators do not include the information, because this is not a mandatory file.\nAnyway, you can create this file with some GIS operations, simplified by GTFSwizard::read_gtfs()\nGTFSwizard::get_shapes reconstructs the shapes table using euclidean approximation, based on the coordinates and sequence of stops for each trip, and may not be accurate.\n\n\nInstall GTFSwizard\nremotes::install_github(\"hrbrmstr/hrbrthemes\") # in 10.2025 this dependency was missing\nremotes::install_github('OPATP/GTFSwizard@main')\n\n\nIf your zip contains shapes.txt that exist but are empty, delete that file before proceeding.\n\nlibrary(GTFSwizard)\ngtfs_noshapes = read_gtfs(\"original/gtfs_without_shapes.zip\") # it will recrreate shapes\nsummary(gtfs_noshapes)\nwrite_gtfs(gtfs_noshapes, \"data/r5r/gtfs_with_shapes.zip\") # save the result\n\n\n\n\n\n\n\nSometimes, event this will not work because other information is missing in the .zip\nConsider searching for another data source, or changing to another city.\n\n\n\n\n\nFilter GTFS by area\nHaving a very large GTFS, as a nation-wide, instead of a city-wide one, can hold too much information not required. You may want to crop it by using tidytransit::filter_feed_by_area()\nThis probably does not affect your r5r network model, anyway.\n\n# example with Gent, Belgium\narea = st_read(\"data/gent.geojson\") # city_limit\n\n# load gtfs\ngtfs_large = tidytransit::read_gtfs(\"https://data.gtfs.be/delijn/gtfs/be-delijn-gtfs.zip\") # direct link\n\n# filter by area\ngtfs_crop = tidytransit::filter_feed_by_area(gtfs_large, area)\n\n# get shapes\ngtfs_large_shapes = shapes_as_sf(gtfs_large$shapes)\ngtfs_crop_shapes = shapes_as_sf(gtfs_crop$shapes)\n\n# compare\nplot(gtfs_large_shapes)\nplot(gtfs_crop_shapes)\n\nwrite_gtfs(gtfs_crop, \"data/r5r/gent_redux.zip\") # save for modelling\n\n \n\n\nCreate transfers.txt\nSome operators do not include the information regarding where can someone change from bus A to bus B, because this is not a mandatory file.\nAnyway, you can create this file with some GIS operations, simplified by gtfsrouter::gtfs_transfer_table()\n\n# Donwload and save zip\ncarris_url = \"https://gateway.carris.pt/gateway/gtfs/api/v2.8/GTFS\" # direct link\ndownload.file(carris_url, destfile = \"original/carris_gtfs.zip\")\n\ncarris_notransfers = gtfsrouter::extract_gtfs(\"original/carris_gtfs.zip\")\ncarris_transfers = gtfsrouter::gtfs_transfer_table(carris_notransfers)\nwrite.csv(carris_transfers[[\"transfers\"]], \"original/transfers.txt\", row.names = F, quote = F)\n# drag and drop this transfers.txt file into the zip file\n\ncarris = tidytransit::read_gtfs(\"original/carris_gtfs.zip\")\ntidytransit::validate_gtfs(carris) # validate\n\n\n\nMerge GTFS sources\nPublic transit analysis takes advantage of the standardized GTFS format. However, its provision by operator makes it difficult for network aggregated analysis, considering connectivity and multimodality. GTFShift::unify() proposes a simple solution to this problem, generating an aggregated GTFS file given several instances of these.\nThe unification produces a single GTFS instance, saved as a ZIP file. Option create_transfers enables the generation of transfers.txt, aggregating close stops, even if from different GTFS.\n\ngtfs_united = GTFShift::unify(gtfs_1, gtfs_2, create_transfers = TRUE)\nwrite_gtfs(gtfs_united, \"data/r5r/gtfs_united.zip\") # save for modelling",
    "crumbs": [
      "Home",
      "r5r",
      "Network setup"
    ]
  },
  {
    "objectID": "network.html#elevation",
    "href": "network.html#elevation",
    "title": "Network setup",
    "section": "Elevation",
    "text": "Elevation\nThis information is useful if your city is somehow hilly, and you are modelling pedestrian and/or bike travel.\nIn the following websites you can export a raster file of Digital Elevation Model (DEM) in .tif format:\n\nelevatr R package\nNasa‚Äôs SRTMGL1 website\nCopernicus EU website\n\n\n\n\nExport dem.tiff from Copernicus using a city_limit.geojson\n\n\n\n\n\n\n\n\nThe dem should be renamed to .tif (single F) instead of .tiff, otherwise it will be ignored in r5r build.\n\n\n\nVerify in R\n\ndem = terra::rast(\"data/Lisbon/Copernicus_30m.tif\") # rename the extension to .tif !!\nterra::plot(dem)",
    "crumbs": [
      "Home",
      "r5r",
      "Network setup"
    ]
  },
  {
    "objectID": "network.html#setting-up-a-routable-transport-network",
    "href": "network.html#setting-up-a-routable-transport-network",
    "title": "Network setup",
    "section": "Setting up a routable transport network",
    "text": "Setting up a routable transport network\nYour folder should contain these files, such as:\n\n\n\n\n\n\n# Load packages\nlibrary(tidyverse)\nlibrary(sf)\noptions(java.parameters = '-Xmx8G') # allocate memory for 8GB \nlibrary(r5r)\n\n\ndata_path= \"data/Lisbon/r5r\" # relative path to your folder containing the required data\nnetwork = build_network(\n  data_path,\n  elevation = \"TOBLER\" # optional. MINETTI or NONE\n)\n\n\n\n\n\n\n\nIf you already have a network.dat file, it will use that pre-build network.\n\n\n\nCheck if your transportation network is correct:\n\ntransit_net = transit_network_to_sf(r5r_lisboa)\nmapview::mapview(transit_net$routes, zcol = \"mode\")",
    "crumbs": [
      "Home",
      "r5r",
      "Network setup"
    ]
  },
  {
    "objectID": "network.html#footnotes",
    "href": "network.html#footnotes",
    "title": "Network setup",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nSee how to export an area with HOT export tool.‚Ü©Ô∏é\nOptional.‚Ü©Ô∏é\nOptional.‚Ü©Ô∏é\nFor instance, see here for Germany: https://opendatalab.de/projects/geojson-utilities/‚Ü©Ô∏é\nYou need an OSM account to use it.‚Ü©Ô∏é",
    "crumbs": [
      "Home",
      "r5r",
      "Network setup"
    ]
  },
  {
    "objectID": "jittering.html",
    "href": "jittering.html",
    "title": "OD Jittering",
    "section": "",
    "text": "Note\n\n\n\nThis page is only relevant when using travel survey data.\nWhen having OD pairs with a macro-scale zoning, we can jitter these desire lines by randomly spread the origins and destinations points at a given area, making the trips (in particular active modes) more realistic (Lovelace, F√©lix, and Carlino 2022).\nFor that, zones, OD pairs, as well as the trip volume are needed.",
    "crumbs": [
      "Home",
      "r5r",
      "OD Jittering"
    ]
  },
  {
    "objectID": "jittering.html#jittered-desire-lines",
    "href": "jittering.html#jittered-desire-lines",
    "title": "OD Jittering",
    "section": "Jittered desire lines",
    "text": "Jittered desire lines\n\nWith od package\nSee the example bellow, using OD tirps between districts in Lisbon, with the od package (Lovelace and Morgan 2024).\n\n# Load packages\nlibrary(sf)\nlibrary(tidyverse)\nlibrary(mapview)\n# install.packages(\"od\")\nlibrary(od)\n\n\n# Load data\n\n# road network\nroad_network = st_read(\"data/Lisbon/Lisbon_road_network.gpkg\")\n\n# polygons\nlisbon_zones = st_read(\"https://github.com/U-Shift/Traffic-Simulation-Models/releases/download/2025/Freguesias_Lx.gpkg\")\n\n# OD data\nod_lisbon = readRDS(url(\"https://github.com/U-Shift/Traffic-Simulation-Models/releases/download/2025/ODtrips_Freguesias_Lx.rds\"))\nod_lisbon = od_lisbon |&gt; \n  filter(Bike &gt; 0) # keep only with more than 0 bike trips\nhead(od_lisbon)\n\n\n\n  DICOFREor11 DICOFREde11    Car  CarP  Bike   Walk  Other  Total    Active\n1      110601      110601 143.98 43.67 12.76 622.82 116.68 939.91 67.621368\n2      110601      110602 136.85 36.10  2.74 403.72 231.32 810.73 50.135063\n3      110601      110607  21.64 18.90  0.00   0.00  23.75  64.29  0.000000\n4      110601      110608 133.25  5.44  0.00   8.65 377.05 524.39  1.649536\n5      110601      110610  48.55  0.00  0.00   0.00  63.55 112.10  0.000000\n6      110601      110611  31.18 22.83  0.00   0.00   7.28  61.29  0.000000\n\n\n\n# create desire lines between centroids\nod_lisbon_dl = od::od_to_sf(od_lisbon, lisbon_zones)\n\nmapview(od_lisbon_dl, zcol = \"Bike\")\n\n\n\n\n\n\n\nod_lisbon_jit = od::od_jitter(\n  od = od_lisbon,\n  z = lisbon_zones,\n  \n  population_column = 8, #total trips\n  disag = FALSE\n)\nod_lisbon_jit_disag = od::od_jitter(\n  od = od_lisbon,\n  z = lisbon_zones,\n  population_column = 8, #total trips\n  disag = TRUE,\n  max_per_od = 200 # max trips per line\n)\n\nmapview::mapview(od_lisbon_jit, lwd = 0.2)\nmapview::mapview(od_lisbon_jit_disag, lwd = 0.2)\n\n\n\n\n\n\njittering\n\n\n\n\n\n\n\n\njittering with disaggregation\n\n\n\n\nSee the od::od_jitter() function for more options.\n\n\nWith odjitter package\nThe same but with Rust, which is faster:\n\nsudo apt install cargo\n# (restart current shell)\n# sudo apt install cmake\n# install odjitter in rust\ncargo install odjitter\n# git clone https://github.com/dabreegster/odjitter && cd odjitter && cargo build --release && cp ./target/release/odjitter /usr/local/bin/\n\n\n# install odjitter in R\nremotes::install_github(\"itsleeds/odjitter\", subdir = \"r\")\n# Load packages\nlibrary(odjitter)\n\n\n# Jitter with disagregation threshold of 200 trips\nod_lisbon_jittered = odjitter::jitter(  #jitter\n  od = od_lisbon,\n  zones = lisbon_zones,\n  subpoints = road_network, # road network verices. we can choose buildings, or so \n  disaggregation_key = \"Total\",\n  disaggregation_threshold = 200\n)\n\nmapview::mapview(od_lisbon_jittered, lwd = 0.2)",
    "crumbs": [
      "Home",
      "r5r",
      "OD Jittering"
    ]
  },
  {
    "objectID": "jittering.html#jittered-origins-and-destinations",
    "href": "jittering.html#jittered-origins-and-destinations",
    "title": "OD Jittering",
    "section": "Jittered origins and destinations",
    "text": "Jittered origins and destinations\nFrom the jittered desire lines to the points of origin and destination.\n\nlibrary(stplanr)\n\n# add an id to the jittered pairs, so we can join later\nod_lisbon_jittered_id = od_lisbon_jittered\nod_lisbon_jittered_id$id = 1:nrow(od_lisbon_jittered_id)\n\n#with stplanr\nod_lisbon_jittered_points = line2df(od_lisbon_jittered)\nod_lisbon_jittered_points_OR = od_lisbon_jittered_points |&gt;\n  select(L1, fx, fy) |&gt; # from\n  rename(id = L1,\n         lon = fx,\n         lat = fy)\nod_lisbon_jittered_points_DE = od_lisbon_jittered_points |&gt;\n  select(L1, tx, ty) |&gt; # to\n  rename(id = L1,\n         lon = tx,\n         lat = ty)\n\n# as sf\nod_lisbon_jittered_points_OR_geo = st_as_sf(od_lisbon_jittered_points_OR,\n                                            coords = c(\"lon\", \"lat\"),\n                                            crs = 4326)\nod_lisbon_jittered_points_DE_geo = st_as_sf(od_lisbon_jittered_points_DE,\n                                            coords = c(\"lon\", \"lat\"),\n                                            crs = 4326)\n\nmapview(od_lisbon_jittered_points_OR_geo, col.regions = \"red\") + \n  mapview(od_lisbon_jittered_points_DE_geo, col.regions = \"blue\")\n\n\n\n\n\n\nAfter routing with r5r, you may want to add the original O and D codes.\n\nod_lisbon_jittered_r5r = od_lisbon_jittered_r5r |&gt;\n  mutate(id = as.integer(from_id)) |&gt;\n  select(id, total_duration, total_distance, route) |&gt;\n  left_join(od_lisbon_jittered_id |&gt;\n              st_drop_geometry(), # drop geom for left_join\n            by=\"id\")\n\n# get geometry back\nod_lisbon_jittered_r5r = st_as_sf(as.data.frame(st_drop_geometry(od_lisbon_jittered_r5r)),\n                                  geometry = od_lisbon_jittered_r5r$geometry)",
    "crumbs": [
      "Home",
      "r5r",
      "OD Jittering"
    ]
  },
  {
    "objectID": "accessibility.html",
    "href": "accessibility.html",
    "title": "Accessibility",
    "section": "",
    "text": "Urban accessibility is defined as how easily people can reach opportunities (jobs, education, services) given the spatial layout of populations, transport networks, and land use.\nIt contrasts with mobility (how people move).\nPlanning should shift focus from maximizing movement to maximizing access (R. H. Pereira and Herszenhut 2023).\nüëâ In this exercises we will adapt from r5r vignettes ‚ÄúIsochrones‚Äù and ‚ÄúAccessibility‚Äù (R. H. M. Pereira et al. 2021)",
    "crumbs": [
      "Home",
      "r5r",
      "Accessibility"
    ]
  },
  {
    "objectID": "accessibility.html#public-transit",
    "href": "accessibility.html#public-transit",
    "title": "Accessibility",
    "section": "Public Transit",
    "text": "Public Transit\nOn a Wednesday at 8:00 a.m., how long will it take me to get from downtown using the subway and bus, with 1 transfer allowed?\n\n# define some parameters\nmode = c(\"SUBWAY\", \"BUS\") # TRANSIT, BUS, SUBWAY, RAIL, CAR, FERRY, WALK, BIKE, TRAM\nmode_egress = \"WALK\" # can be BIKE\nmax_walk_time = 10 # in minutes\nmax_trip_duration = 90 # in minutes\ntime_window = 120 # in minutes\ntime_intervals &lt;- seq(0, 100, 10)\ndeparture_datetime_HP = as.POSIXct(\"01-10-2025 8:00:00\", format = \"%d-%m-%Y %H:%M:%S\") # quarta-feira\n\n# calculate travel time matrix\nttm_zer_HP_PT = travel_time_matrix(r5r_network = r5r_lisboa,\n                              origins = BAIXA,\n                              destinations = POINTS,\n                              mode = mode,\n                              mode_egress = mode_egress,\n                              departure_datetime = departure_datetime_HP,\n                              max_walk_time = max_walk_time,\n                              max_trip_duration = max_trip_duration,\n                              time_window = time_window,\n                              max_rides = 2, # max 1 transfer\n                              verbose = FALSE)\n\nsummary(ttm_zer_HP_PT$travel_time_p50)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n   1.00   29.00   37.00   37.86   45.25   85.00 \n\n# add coordinates of destinations to travel time matrix\nttm_zer_HP_PT = ttm_zer_HP_PT |&gt;\n  mutate(id = as.integer(to_id)) |&gt; \n  left_join(GRID_data)\n\n# interpolate estimates to get spatially smooth result\ntravel_times.interp &lt;- with(na.omit(ttm_zer_HP_PT), interp(lon, lat, travel_time_p50)) |&gt;\n  with(cbind(travel_time=as.vector(z),  # Column-major order\n             x=rep(x, times=length(y)),\n             y=rep(y, each=length(x)))) |&gt;\n  as.data.frame() |&gt; na.omit()\n\n\n\nCode\n# find isochrone's bounding box to crop the map below\nbb_x &lt;- c(min(travel_times.interp$x), max(travel_times.interp$x))\nbb_y &lt;- c(min(travel_times.interp$y), max(travel_times.interp$y))\n# plot\nplotHP = ggplot(travel_times.interp) +\n  geom_contour_filled(aes(x = x, y = y, z = travel_time), alpha = .7) +\n  geom_sf(data = road_network_base, color = \"gray55\", lwd = 0.5, alpha = 0.4) +\n  geom_sf(data = city_limit, fill = \"transparent\", color = \"grey30\") +\n  geom_point(aes(x = lon, y = lat, color = 'Baixa'), data = BAIXA) +\n  scale_fill_viridis_d(direction = -1, option = 'B') +\n  scale_color_manual(values = c('Baixa' = 'black')) +\n  scale_x_continuous(expand = c(0, 0)) +\n  scale_y_continuous(expand = c(0, 0)) +\n  coord_sf(xlim = bb_x, ylim = bb_y) +\n  labs(\n    title = \"Reaching from Baixa (Carris + Metro)\",\n    subtitle = \"at 8am wednesday - 1 transf max\",\n    fill = \"Trip duration \\n[min]\",\n    color = ''\n  ) +\n  theme_minimal() +\n  theme(axis.title = element_blank())\n\nplotHP",
    "crumbs": [
      "Home",
      "r5r",
      "Accessibility"
    ]
  },
  {
    "objectID": "accessibility.html#car",
    "href": "accessibility.html#car",
    "title": "Accessibility",
    "section": "Car",
    "text": "Car\n\nmode = \"CAR\"\n\n# calculate travel time matrix\nttm_zer_HP_car = travel_time_matrix(r5r_network = r5r_lisboa,\n                              origins = BAIXA,\n                              destinations = POINTS,\n                              mode = mode,\n                              mode_egress = mode_egress,\n                              departure_datetime = departure_datetime_HP,\n                              max_walk_time = max_walk_time, # irrelevant\n                              max_trip_duration = max_trip_duration, \n                              time_window = time_window, # irrelevant\n                              verbose = FALSE)\n\nsummary(ttm_zer_HP_car$travel_time_p50)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n   2.00   11.00   13.00   12.87   15.00   34.00\n\n\nCode\n# add coordinates of destinations to travel time matrix\nttm_zer_HP_car = ttm_zer_HP_car |&gt;\n  left_join(POINTS, by = c(\"to_id\" = \"id\"))\n\n# interpolate estimates to get spatially smooth result\ntravel_times.interp &lt;- with(na.omit(ttm_zer_HP_car), interp(lon, lat, travel_time_p50)) |&gt;\n  with(cbind(travel_time=as.vector(z),  # Column-major order\n             x=rep(x, times=length(y)),\n             y=rep(y, each=length(x)))) |&gt;\n  as.data.frame() |&gt; na.omit()\n\n# plot\n# find isochrone's bounding box to crop the map below\nbb_x &lt;- c(min(travel_times.interp$x), max(travel_times.interp$x))\nbb_y &lt;- c(min(travel_times.interp$y), max(travel_times.interp$y))\n# plot\nplotHP_car = ggplot(travel_times.interp) +\n  geom_contour_filled(aes(x = x, y = y, z = travel_time), alpha = .7) +\n  geom_sf(data = road_network_base, color = \"gray55\", lwd = 0.5, alpha = 0.4) +\n  geom_sf(data = city_limit, fill = \"transparent\", color = \"grey30\") +\n  geom_point(aes(x = lon, y = lat, color = 'Baixa'), data = BAIXA) +\n  scale_fill_viridis_d(direction = -1, option = 'B') +\n  scale_color_manual(values = c('Baixa' = 'black')) +\n  scale_x_continuous(expand = c(0, 0)) +\n  scale_y_continuous(expand = c(0, 0)) +\n  coord_sf(xlim = bb_x, ylim = bb_y) +\n  labs(\n    title = \"Reaching from Baixa (Car)\",\n    subtitle = \"at 8am wednesday\",\n    fill = \"Trip duration \\n[min]\",\n    color = ''\n  ) +\n  theme_minimal() +\n  theme(axis.title = element_blank())\n\nplotHP_car",
    "crumbs": [
      "Home",
      "r5r",
      "Accessibility"
    ]
  },
  {
    "objectID": "accessibility.html#bike",
    "href": "accessibility.html#bike",
    "title": "Accessibility",
    "section": "Bike",
    "text": "Bike\n\nmode = \"BICYCLE\"\nmax_lts = 3\n\n# calculate travel time matrix\nttm_zer_HP_bike = travel_time_matrix(r5r_network = r5r_lisboa,\n                              origins = BAIXA,\n                              destinations = POINTS,\n                              mode = mode,\n                              max_lts = max_lts,\n                              mode_egress = mode_egress, # irrelevant\n                              departure_datetime = departure_datetime_HP, # irrelevant\n                              max_walk_time = max_walk_time, # irrelevant\n                              max_trip_duration = max_trip_duration,\n                              time_window = time_window, # irrelevant\n                              verbose = FALSE)\n\nsummary(ttm_zer_HP_bike$travel_time_p50)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n   0.00   29.00   41.00   38.96   50.00   76.00 \n\n\nCode\n# add coordinates of destinations to travel time matrix\nttm_zer_HP_bike = ttm_zer_HP_bike |&gt;\n  left_join(POINTS, by = c(\"to_id\" = \"id\"))\n\n# interpolate estimates to get spatially smooth result\ntravel_times.interp &lt;- with(na.omit(ttm_zer_HP_bike), interp(lon, lat, travel_time_p50)) |&gt;\n  with(cbind(travel_time=as.vector(z),  # Column-major order\n             x=rep(x, times=length(y)),\n             y=rep(y, each=length(x)))) |&gt;\n  as.data.frame() |&gt; na.omit()\n\n# plot\n# find isochrone's bounding box to crop the map below\nbb_x &lt;- c(min(travel_times.interp$x), max(travel_times.interp$x))\nbb_y &lt;- c(min(travel_times.interp$y), max(travel_times.interp$y))\n# plot\nplotHP_car = ggplot(travel_times.interp) +\n  geom_contour_filled(aes(x = x, y = y, z = travel_time), alpha = .7) +\n  geom_sf(data = road_network_base, color = \"gray55\", lwd = 0.5, alpha = 0.4) +\n  geom_sf(data = city_limit, fill = \"transparent\", color = \"grey30\") +\n  geom_point(aes(x = lon, y = lat, color = 'Baixa'), data = BAIXA) +\n  scale_fill_viridis_d(direction = -1, option = 'B') +\n  scale_color_manual(values = c('Baixa' = 'black')) +\n  scale_x_continuous(expand = c(0, 0)) +\n  scale_y_continuous(expand = c(0, 0)) +\n  coord_sf(xlim = bb_x, ylim = bb_y) +\n  labs(\n    title = \"Reaching from Baixa (Bike)\",\n    subtitle = \"at 8am wednesday - max LTS 3\",\n    fill = \"Trip duration \\n[min]\",\n    color = ''\n  ) +\n  theme_minimal() +\n  theme(axis.title = element_blank())\n\nplotHP_car",
    "crumbs": [
      "Home",
      "r5r",
      "Accessibility"
    ]
  },
  {
    "objectID": "accessibility.html#easier-approach",
    "href": "accessibility.html#easier-approach",
    "title": "Accessibility",
    "section": "Easier approach",
    "text": "Easier approach\nThere are other ways of making these maps, but with lower details, such as no destinations. See r5r::isochrones() function.\n\nService area\nThis function also allows to find service areas.\n\n# estimate line-based isochrone from origin\niso_lines = isochrone(\n  r5r_network = r5r_lisboa,\n  origins = BAIXA,\n  mode = \"walk\",\n  polygon_output = FALSE,\n  departure_datetime = departure_datetime_HP,\n  cutoffs = seq(0, 120, 20)\n  )\n\n\n\nCode\n# plot\n# used cols4all::c4a_gui()\ncolors &lt;- c('#FFFFCC','#C7E9B4', '#7FCDBB','#41B6C4','#2C7FB8','#253494','black')\n# last one for the origin point\n\nggplot() +\n  geom_sf(data = iso_lines, aes(color=factor(isochrone))) +\n  geom_sf(data = city_limit, fill = \"transparent\", color = \"grey30\") +\n  geom_point(aes(x = lon, y = lat, color = 'Baixa'), data = BAIXA) +\n  scale_color_manual(values = colors) +\n  labs(\n    title = \"Reaching from Baixa (Walk)\",\n    subtitle = \"Service area\",\n    color = \"Trip duration \\n[min]\"\n  ) +\n  theme_minimal() +\n  theme(axis.title = element_blank())",
    "crumbs": [
      "Home",
      "r5r",
      "Accessibility"
    ]
  },
  {
    "objectID": "accessibility.html#spatial-interpolation",
    "href": "accessibility.html#spatial-interpolation",
    "title": "Accessibility",
    "section": "Spatial interpolation",
    "text": "Spatial interpolation\n\n# interpolate estimates to get spatially smooth result\naccess_schools &lt;- access1 %&gt;% \n  filter(opportunity == \"schools\") %&gt;%\n  inner_join(POINTS |&gt; mutate(id = as.integer(id)), by='id') %&gt;%\n  with(interp::interp(lon, lat, accessibility)) %&gt;%\n  with(cbind(acc=as.vector(z),  # Column-major order\n             x=rep(x, times=length(y)),\n             y=rep(y, each=length(x)))) %&gt;% as.data.frame() %&gt;% na.omit() %&gt;%\n  mutate(opportunity = \"schools\")\n\naccess_health &lt;- access1 %&gt;% \n  filter(opportunity == \"healthcare\") %&gt;%\n  inner_join(POINTS |&gt; mutate(id = as.integer(id)), by='id') %&gt;%\n  with(interp::interp(lon, lat, accessibility)) %&gt;%\n  with(cbind(acc=as.vector(z),  # Column-major order\n             x=rep(x, times=length(y)),\n             y=rep(y, each=length(x)))) %&gt;% as.data.frame() %&gt;% na.omit() %&gt;%\n  mutate(opportunity = \"healthcare\")\n\naccess_sports &lt;- access1 %&gt;% \n  filter(opportunity == \"sport\") %&gt;%\n  inner_join(POINTS |&gt; mutate(id = as.integer(id)), by='id') %&gt;%\n  with(interp::interp(lon, lat, accessibility)) %&gt;%\n  with(cbind(acc=as.vector(z),  # Column-major order\n             x=rep(x, times=length(y)),\n             y=rep(y, each=length(x)))) %&gt;% as.data.frame() %&gt;% na.omit() %&gt;%\n  mutate(opportunity = \"sports\")\n\n\naccess.interp &lt;- rbind(access_schools, access_health, access_sports)\n\n# plot\nggplot(na.omit(access.interp)) +\n  geom_contour_filled(aes(x=x, y=y, z=acc), alpha=.7) +\n  geom_sf(data = road_network_base, color = \"gray55\", lwd=0.5, alpha = 0.5) +\n  geom_sf(data = city_limit, fill = \"transparent\", color = \"grey30\") +\n  scale_fill_viridis_d(direction = -1, option = 'B') +\n  scale_x_continuous(expand=c(0,0)) +\n  scale_y_continuous(expand=c(0,0)) +\n  coord_sf(xlim = bb_x, ylim = bb_y, datum = NA) + \n  labs(fill = \"Number of\\nfacilities within\\n20 minutes\") +\n  theme_void() +\n  facet_wrap(~opportunity)",
    "crumbs": [
      "Home",
      "r5r",
      "Accessibility"
    ]
  },
  {
    "objectID": "accessibility.html#population-estimate",
    "href": "accessibility.html#population-estimate",
    "title": "Accessibility",
    "section": "Population estimate",
    "text": "Population estimate\nWe can also estimate population reach from downtown with PTransit (1 transfer, peak hour)\n\n\nCode\n# calculate population accessible\naccess &lt;- ttm_zer_HP_PT |&gt; # estimaded before!\n  filter(travel_time_p50 &lt;= 60) |&gt;      # keep trips within 30 minutes\n  group_by(to_id) |&gt;\n  summarise(acc = sum(residents), .groups = \"drop\")\naccess = left_join(access, ttm_zer_HP_PT)\n\n# interpolate estimates to get spatially smooth result\naccess.interp = access |&gt;\n  with(interp(lon, lat, acc)) |&gt;\n  with(cbind(acc=as.vector(z),  # Column-major order\n             x=rep(x, times=length(y)),\n             y=rep(y, each=length(x)))) |&gt; as.data.frame() |&gt; na.omit()\n\n# plot\nggplot(na.omit(access.interp)) +\n  geom_contour_filled(aes(x=x, y=y, z=acc), alpha=.8) +\n  geom_sf(data = road_network_base, color = \"gray55\", lwd=0.5, alpha = 0.5) +\n  geom_sf(data = city_limit, fill = \"transparent\", color = \"grey30\") +\n  scale_fill_viridis_d(direction = -1, option = 'B') +\n  scale_x_continuous(expand=c(0,0)) +\n  scale_y_continuous(expand=c(0,0)) +\n  coord_sf(xlim = bb_x, ylim = bb_y) + \n  labs(\n    title = \"Reaching population from Baixa (Carris + Metro)\",\n    subtitle = \"at 8am wednesday - 1 transf max\",\n    fill = \"Population in\\n60 minutos\") +\n  theme_minimal() +\n  theme(axis.title = element_blank())\n\n\n\n\n\n\n\nHow many residents can reach downtown in 15, 30, 45 and 60 minutes?\n\npoplisboa = sum(POINTS$residents) #\n100* sum(access$residents[access$travel_time_p50 &lt;= 15]) / poplisboa # 2.5%\n100* sum(access$residents[access$travel_time_p50 &lt;= 30]) / poplisboa # 38.6%\n100* sum(access$residents[access$travel_time_p50 &lt;= 45]) / poplisboa # 84.8%\n100* sum(access$residents[access$travel_time_p50 &lt;= 60]) / poplisboa # 97.3%\n\n\n\n\n\n\n\n\nTrip duration\n(up to‚Ä¶)\nResidents\n\n\n\n\n15 min\n2.5 %\n\n\n30 min\n38.6 %\n\n\n45 min\n84.8%\n\n\n60 min\n97.3%\n\n\n\n\n\n\n\n\n\nOther accessibility measures\n\n\n\nRead Chapter 3 from R. H. Pereira and Herszenhut (2023) for other accessibility estimates.\n\n\n\nStop r5r model\n\nr5r::stop_r5(r5r_lisboa)\nrJava::.jgc(R.gc = TRUE)",
    "crumbs": [
      "Home",
      "r5r",
      "Accessibility"
    ]
  },
  {
    "objectID": "software.html",
    "href": "software.html",
    "title": "Software",
    "section": "",
    "text": "There are several software options for modeling transportation systems.\nTo choose a traffic simulation software to work with can depend on different things to consider. You may use more than one software, depending on the scale you are working with, and on other characteristics.",
    "crumbs": [
      "Home",
      "Software"
    ]
  },
  {
    "objectID": "software.html#macro-vs.-micro",
    "href": "software.html#macro-vs.-micro",
    "title": "Software",
    "section": "Macro vs.¬†Micro",
    "text": "Macro vs.¬†Micro\n\nMacro simulators\nSome softwares can be more appropriated if using a large scale, such as regional or city-wide area. For instance, the traffic impacts on the development of a new centrality (hospital, airport), or in the introduction of a new bridge or freeway can be simulated with macro simulator software.\nPTV Visum, Aimsun, r5r, and MatSim are examples of software to deal with a large scale simulation.\nFor macro simulations it is essential do consider zoning, flows, etc.\nUsually this type of simulators can smoothly integrate Public Transport information, such as GTFS files.\n\n\nMicro simulators\nWant to simulate changes at a street or neighbourhood level? Then micro simulator software should be used.\nPTV Visim, SUMO, and A/B Street are examples of software to deal with a micro scale simulation.",
    "crumbs": [
      "Home",
      "Software"
    ]
  },
  {
    "objectID": "software.html#paid-licence-vs.-free",
    "href": "software.html#paid-licence-vs.-free",
    "title": "Software",
    "section": "Paid (Licence) vs.¬†Free",
    "text": "Paid (Licence) vs.¬†Free\n\nPaid\nAvailable commercial software is largely used at many companies and consultants. Universities also usually offer licence access to students and researchers. At IST we provide access to PTV Visum licence for registered students1.\nSome groups provide a student version, which typically does not include all the features.\nPTV Vissim and Visum, and Aimsum are examples of commercial simulation software.\n\n\nFree\nFree and open source software is getting more robust, and should not be overlooked.\nMatSim, r5r, and SUMO are examples of free and open source simulation software.",
    "crumbs": [
      "Home",
      "Software"
    ]
  },
  {
    "objectID": "software.html#operating-system",
    "href": "software.html#operating-system",
    "title": "Software",
    "section": "Operating System",
    "text": "Operating System\nTo choose a software to work with, you should also consider the operation system of your personal computer (Windows, MacOS, Linux based).\nPTV Visum and Visim are only available for Windows.\nYou may always use virtual machines to have another OS in your PC, but that comes with memory and performance cost.\n\nFor MacOS users, UTM is a good free option. Keep in mind that the University of Lisbon provides Windows stutent‚Äôs licences.\nFor Linux (Ubuntu or Debian) users, Gnome Boxes are an interesting option to run Windows.\nFor Windows users, you should have no problem using any software.",
    "crumbs": [
      "Home",
      "Software"
    ]
  },
  {
    "objectID": "software.html#instalation-and-usage",
    "href": "software.html#instalation-and-usage",
    "title": "Software",
    "section": "Instalation and Usage",
    "text": "Instalation and Usage\nWe only offer guidance to setup some of the available software2.\nPlease see each software page for more details.",
    "crumbs": [
      "Home",
      "Software"
    ]
  },
  {
    "objectID": "software.html#footnotes",
    "href": "software.html#footnotes",
    "title": "Software",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nContact Filipe Moura or Rosa F√©lix to access Visum.‚Ü©Ô∏é\nIf you use other traffic simulation software, you may contribute to this website and create another tutorial üôÇ. Fork and Pull Request in this Github repo.‚Ü©Ô∏é",
    "crumbs": [
      "Home",
      "Software"
    ]
  },
  {
    "objectID": "Oeiras2024/Alfragide_Zonas_2021.html",
    "href": "Oeiras2024/Alfragide_Zonas_2021.html",
    "title": "Modelling of Tranport Systems",
    "section": "",
    "text": "&lt;!DOCTYPE qgis PUBLIC ‚Äòhttp://mrcc.com/qgis.dtd‚Äô ‚ÄòSYSTEM‚Äô&gt;     dataset\n\n\n                PROJCRS[‚ÄúETRS89 / Portugal TM06‚Äù,BASEGEOGCRS[‚ÄúETRS89‚Äù,ENSEMBLE[‚ÄúEuropean Terrestrial Reference System 1989 ensemble‚Äù,MEMBER[‚ÄúEuropean Terrestrial Reference Frame 1989‚Äù],MEMBER[‚ÄúEuropean Terrestrial Reference Frame 1990‚Äù],MEMBER[‚ÄúEuropean Terrestrial Reference Frame 1991‚Äù],MEMBER[‚ÄúEuropean Terrestrial Reference Frame 1992‚Äù],MEMBER[‚ÄúEuropean Terrestrial Reference Frame 1993‚Äù],MEMBER[‚ÄúEuropean Terrestrial Reference Frame 1994‚Äù],MEMBER[‚ÄúEuropean Terrestrial Reference Frame 1996‚Äù],MEMBER[‚ÄúEuropean Terrestrial Reference Frame 1997‚Äù],MEMBER[‚ÄúEuropean Terrestrial Reference Frame 2000‚Äù],MEMBER[‚ÄúEuropean Terrestrial Reference Frame 2005‚Äù],MEMBER[‚ÄúEuropean Terrestrial Reference Frame 2014‚Äù],ELLIPSOID[‚ÄúGRS 1980‚Äù,6378137,298.257222101,LENGTHUNIT[‚Äúmetre‚Äù,1]],ENSEMBLEACCURACY[0.1]],PRIMEM[‚ÄúGreenwich‚Äù,0,ANGLEUNIT[‚Äúdegree‚Äù,0.0174532925199433]],ID[‚ÄúEPSG‚Äù,4258]],CONVERSION[‚ÄúPortugual TM06‚Äù,METHOD[‚ÄúTransverse Mercator‚Äù,ID[‚ÄúEPSG‚Äù,9807]],PARAMETER[‚ÄúLatitude of natural origin‚Äù,39.6682583333333,ANGLEUNIT[‚Äúdegree‚Äù,0.0174532925199433],ID[‚ÄúEPSG‚Äù,8801]],PARAMETER[‚ÄúLongitude of natural origin‚Äù,-8.13310833333333,ANGLEUNIT[‚Äúdegree‚Äù,0.0174532925199433],ID[‚ÄúEPSG‚Äù,8802]],PARAMETER[‚ÄúScale factor at natural origin‚Äù,1,SCALEUNIT[‚Äúunity‚Äù,1],ID[‚ÄúEPSG‚Äù,8805]],PARAMETER[‚ÄúFalse easting‚Äù,0,LENGTHUNIT[‚Äúmetre‚Äù,1],ID[‚ÄúEPSG‚Äù,8806]],PARAMETER[‚ÄúFalse northing‚Äù,0,LENGTHUNIT[‚Äúmetre‚Äù,1],ID[‚ÄúEPSG‚Äù,8807]]],CS[Cartesian,2],AXIS[‚Äúeasting (X)‚Äù,east,ORDER[1],LENGTHUNIT[‚Äúmetre‚Äù,1]],AXIS[‚Äúnorthing (Y)‚Äù,north,ORDER[2],LENGTHUNIT[‚Äúmetre‚Äù,1]],USAGE[SCOPE[‚ÄúTopographic mapping (medium scale).‚Äù],AREA[‚ÄúPortugal - mainland - onshore.‚Äù],BBOX[36.95,-9.56,42.16,-6.19]],ID[‚ÄúEPSG‚Äù,3763]] +proj=tmerc +lat_0=39.6682583333333 +lon_0=-8.13310833333333 +k=1 +x_0=0 +y_0=0 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs 1721 3763 EPSG:3763 ETRS89 / Portugal TM06 tmerc EPSG:7019 false"
  },
  {
    "objectID": "casestudy.html",
    "href": "casestudy.html",
    "title": "Macro Case Study",
    "section": "",
    "text": "Please download the VISUM project file (.ver) with the base data that you will need.\n\n\nWe are using a road network exported from OpenStreetMap.\nWe already imported that network to this project as follows:\n\nSelect only Urban Road Network (to keep the principal roads)\n\n\nThis is what it looks like when importing from OSM.\n\n\n\n\nStart by these ones (General, and links not connected to the network)\n\nignore warnings\nSet to active the ones you want to have a look. They are now active/selected. Delete if needed (DEL button)\n\n\n\n\n\nThese are the zones to consider in the area.\nThey are from census 2021 sections, and aggregated in larger TAZ.\n\nThis is how it looks like after importing the shapefile of zones to the project.\n\n\n\nWith zones from census 21 (aggregation of sub-sections)\n\n\n\n\n\n\n\n\nNote\n\n\n\nWe already added the external zones (rest of the world) and the associated connectors to the road network.\n\n\n\n\n\n\nCreate an OD matrix\n\n\n\n\n\n\nGive it a proper name.\nAnd copy-paste data from excel\n\nNow you have your OD matrix with data for your HA Group",
    "crumbs": [
      "Home",
      "Vissim and Visum",
      "Macro Case Study"
    ]
  },
  {
    "objectID": "casestudy.html#road-network",
    "href": "casestudy.html#road-network",
    "title": "Macro Case Study",
    "section": "",
    "text": "We are using a road network exported from OpenStreetMap.\nWe already imported that network to this project as follows:\n\nSelect only Urban Road Network (to keep the principal roads)\n\n\nThis is what it looks like when importing from OSM.\n\n\n\n\nStart by these ones (General, and links not connected to the network)\n\nignore warnings\nSet to active the ones you want to have a look. They are now active/selected. Delete if needed (DEL button)",
    "crumbs": [
      "Home",
      "Vissim and Visum",
      "Macro Case Study"
    ]
  },
  {
    "objectID": "casestudy.html#zones",
    "href": "casestudy.html#zones",
    "title": "Macro Case Study",
    "section": "",
    "text": "These are the zones to consider in the area.\nThey are from census 2021 sections, and aggregated in larger TAZ.\n\nThis is how it looks like after importing the shapefile of zones to the project.\n\n\n\nWith zones from census 21 (aggregation of sub-sections)\n\n\n\n\n\n\n\n\nNote\n\n\n\nWe already added the external zones (rest of the world) and the associated connectors to the road network.",
    "crumbs": [
      "Home",
      "Vissim and Visum",
      "Macro Case Study"
    ]
  },
  {
    "objectID": "casestudy.html#od-matrix",
    "href": "casestudy.html#od-matrix",
    "title": "Macro Case Study",
    "section": "",
    "text": "Create an OD matrix\n\n\n\n\n\n\nGive it a proper name.\nAnd copy-paste data from excel\n\nNow you have your OD matrix with data for your HA Group",
    "crumbs": [
      "Home",
      "Vissim and Visum",
      "Macro Case Study"
    ]
  },
  {
    "objectID": "casestudy.html#create-a-link",
    "href": "casestudy.html#create-a-link",
    "title": "Macro Case Study",
    "section": "Create a link",
    "text": "Create a link\n\nI will first check the characteristics of the previous link that I‚Äôm connecting to, by double-click the link in the editor, and see the details. The Quick View panel also shows some of its information.\n\nThis is a Type no 50.\nCreate a link by connecting both nodes.\n\nWhen creating a link, a window will popup to define some of the link parameters. In this case I will also make it a type 50 link.\n\n\nClicking 2 times in the new link, you can change some of the parameters. It will highlight the ones that are not mirrored to the opposite direction - you should also transfer the new modifications.\n\nTo make realistic links, activate background map before proceeding.\n\nVerify if the link is well connected with Check network integrity, or estimating a shortest path between zones (with connectors).",
    "crumbs": [
      "Home",
      "Vissim and Visum",
      "Macro Case Study"
    ]
  },
  {
    "objectID": "casestudy.html#shortest-path",
    "href": "casestudy.html#shortest-path",
    "title": "Macro Case Study",
    "section": "Shortest path",
    "text": "Shortest path\n\nClick on 2 zones and run.\n\nSee the opposite direction\n\nReset for a new one.",
    "crumbs": [
      "Home",
      "Vissim and Visum",
      "Macro Case Study"
    ]
  },
  {
    "objectID": "casestudy.html#flow-bundle",
    "href": "casestudy.html#flow-bundle",
    "title": "Macro Case Study",
    "section": "Flow Bundle",
    "text": "Flow Bundle\nThe Flow Bundle function can be useful for quantifying the traffic volume in a single link, broken down by the origins/destinations which have the most weight in that link.\nGraphics ‚ü∂ Flow Bundle ‚ü∂ choose the link ‚ü∂ Play ‚ü∂ go to matrices and see the new Formula Matrices/ Flow Bundle ‚ü∂ list view ‚ü∂ sort by volume.",
    "crumbs": [
      "Home",
      "Vissim and Visum",
      "Macro Case Study"
    ]
  },
  {
    "objectID": "casestudy.html#selection-mode",
    "href": "casestudy.html#selection-mode",
    "title": "Macro Case Study",
    "section": "Selection Mode",
    "text": "Selection Mode",
    "crumbs": [
      "Home",
      "Vissim and Visum",
      "Macro Case Study"
    ]
  },
  {
    "objectID": "casestudy.html#labels",
    "href": "casestudy.html#labels",
    "title": "Macro Case Study",
    "section": "Labels",
    "text": "Labels\nChange the zone label to name:\n\n\n\n\n\n\nThe same if you want to remove the symbol representation of links\n\nYou can save these visualization as a Graphic parameter file, so you can shift between one or more, depending on the assessment you are doing.",
    "crumbs": [
      "Home",
      "Vissim and Visum",
      "Macro Case Study"
    ]
  },
  {
    "objectID": "casestudy.html#footnotes",
    "href": "casestudy.html#footnotes",
    "title": "Macro Case Study",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nPrivate Transport‚Ü©Ô∏é",
    "crumbs": [
      "Home",
      "Vissim and Visum",
      "Macro Case Study"
    ]
  },
  {
    "objectID": "micro.html",
    "href": "micro.html",
    "title": "Micro Case Study",
    "section": "",
    "text": "You may use an intersection file already prepared to be used with VISSIM, like this one:\nThis file is available at Fenix, for registered students.\nHow did this file was converted from OpenStreetMap? üßê",
    "crumbs": [
      "Home",
      "Vissim and Visum",
      "Micro Case Study"
    ]
  },
  {
    "objectID": "micro.html#from-openstreetmap-to-vissim",
    "href": "micro.html#from-openstreetmap-to-vissim",
    "title": "Micro Case Study",
    "section": "From OpenStreetMap to VISSIM",
    "text": "From OpenStreetMap to VISSIM\n\nRequirements\nThis will require:\n\nVISSIM installed with an active license\nPython 3.x, and the following packages\n\nwin32com\ngdal\n\nMicrosoft Visual C++ build tools\nOptional: OSGeo4W1\n\n\n\nOpenStreetMap\nGo to OpenStreetMap and zoom into your area.\nSelect Export and save the map.osm file.\n\nYou don‚Äôt need to open that file now.\n\n\nOSM2VISSIM tool\n\nGo to the OSM2VISSIM tool Github page, and download this OSM2VISSIM_v0.1.py file.\n\n\n\nCreate a folder (wherever you want) and put there this .py file and the .osm file exported before. Now copy your folder path!\n\n\n\nIf you have OSGeo4W installed2, open the shell. It will look like this:\n\n\n\nNavigate to your created folder, using cd yourfolderpath\nNow, run python OSM2VISSIM_v0.1.py\n\n\n\nThis will open a dialogue window where you are supposed to type your .osm file name.\nMine is gago\n\n\n\nPress Set.\n\n\n\n\n\n\n\nDon‚Äôt worry! Things are happening even if you don‚Äôt notice. Just be patient and wait.\n\n\n\nThis will create a new file, and open VISSIM automatically.\nNote: If you go to the Network tab and don‚Äôt see anything, even after clicking on zoom to network button, close VISSIM, and close the Shell. This happened to me every first time.\n\nRepeat again the steps from 1 to 7.\n\nThis will open VISSIM automatically and now the shell will show things happening:\n\nWait until VISSIM it closes automatically - don‚Äôt click anything.\n\nYou may now close the OSGeo4W shell.\n\nA few more files were created now:\n\n\n\nAt VISSIM\nOpen the file name.inpx and close the Start Page.\nAt Network Editor panel, click Show entire network:\n\nAs you may note, your network is not exactly in place, when comparing to a basemap. ü•¥\n\nTo adjust this, you may either move the basemap or the network.\nFirst, with the distance tool, measure the distance of one reference point of the network to where it should be placed, in both X and Y directions.\n\nThen Edit ‚ü∂ Move Network\n\nRepeat the process until the network intersection is centred with the intersection in the basemap.\nSave your network file! üéâ\nThis process resulted in the abovementioned file.\nNo go on and adjust the details that require some attention.",
    "crumbs": [
      "Home",
      "Vissim and Visum",
      "Micro Case Study"
    ]
  },
  {
    "objectID": "micro.html#footnotes",
    "href": "micro.html#footnotes",
    "title": "Micro Case Study",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nThis installation already comes with all the required packages.‚Ü©Ô∏é\nYou may do everything on the cmd (command line prompt terminal), but some errors may be output.‚Ü©Ô∏é",
    "crumbs": [
      "Home",
      "Vissim and Visum",
      "Micro Case Study"
    ]
  },
  {
    "objectID": "import_osm/OSM2VISSIM-main/LICENSE.html",
    "href": "import_osm/OSM2VISSIM-main/LICENSE.html",
    "title": "Modelling of Tranport Systems",
    "section": "",
    "text": "MIT License\nCopyright (c) 2023 BME Road Traffic Control Laboratory\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the ‚ÄúSoftware‚Äù), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\nTHE SOFTWARE IS PROVIDED ‚ÄúAS IS‚Äù, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE."
  },
  {
    "objectID": "scenarios.html",
    "href": "scenarios.html",
    "title": "Scenarios",
    "section": "",
    "text": "With the same method presented in Accessibility, let‚Äôs compare the population that can be reach from city center on a peak hour and a Sunday evening, using public transit and max 1 transfer.\n\n\nFirst, we can have a look at the available routes on both time periods. We use tidytransit::filter_feed_by_date() function, to filter our GTFS by day and by hour.\n\n\nCode\n# Example with Carris\ncarris_different_trips_all = length(unique(gtfs_carris$trips$trip_id)) # 53028\n\n# wednesday morning\ncarris_wednesday = gtfs_carris |&gt; filter_feed_by_date(\"2025-10-01\")\ncarris_different_trips_wednesday = length(unique(carris_wednesday$trips$trip_id)) # 11504\ncarris_wednesday_peakh = gtfs_carris |&gt; filter_feed_by_date(\"2025-10-01\",\n                                                            min_departure_time = \"08:00:00\",\n                                                            max_arrival_time = \"09:00:00\")\ncarris_different_trips_wednesday_h = length(unique(carris_wednesday_peakh$trips$trip_id)) # 1352\n\n# sunday evening\ncarris_sunday = gtfs_carris |&gt; filter_feed_by_date(\"2025-10-05\")\ncarris_different_trips_sunday = length(unique(carris_sunday$trips$trip_id)) # 6268\ncarris_sunday_peakh = gtfs_carris |&gt; filter_feed_by_date(\"2025-10-05\",\n                                                          min_departure_time = \"22:00:00\",\n                                                          max_arrival_time = \"23:00:00\")\ncarris_different_trips_sunday_h = length(unique(carris_sunday_peakh$trips$trip_id)) # 264\n\n# comparision\ncarris_different_trips_sunday/carris_different_trips_wednesday # 54%\ncarris_different_trips_sunday_h/carris_different_trips_wednesday_h # 19%\n\n\nFor instance, for Carris (bus operator), on a Sunday there are 54% of the departures of a Wednesday, and on a Sunday evening (22h) there are 19% of the departures that are on a Wednesday morning (8h).\n\n\nBy considering the PTransit stops as destinations (and not population), we can also estimate how many bus stops are reachable, in total and by number of transfers needed, for each our.\nThese estimates are based on GTFS data only, and do not rely on r5r.\n\nsummary(gtfs_carris)\n\ntidygtfs object\nfiles        agency, stops, routes, trips, stop_times, calendar, calendar_dates, shapes, transfers\nagency       Carris\nservice      from 2025-09-01 to 2025-12-01\nuses         stop_times (no frequencies)\n# routes       175\n# trips      53028\n# stop_ids    2341\n# stop_names  1139\n# shapes       307\n\n# We will use the Cais Sodr√© bus stop name\nfrom_station = \"Cais Sodr√©\"\nstop_times_carris = filter_stop_times(gtfs_carris, \"2025-10-01\", \"08:00:00\", \"09:00:00\")\ntrip_duration_cais = travel_times(stop_times_carris, from_station, stop_dist_check = FALSE)\n\nnrow(trip_duration_cais) # 989\n\nsummary(trip_duration_cais$travel_time/60) # in minutos\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n   0.00   19.85   29.87   29.72   40.02   62.30 \nNot counting the waiting time at Cais do Sodr√© it is possible to reach 989 stops in the network (42%) during rush hour‚Äîwithin the 1 hour time frame defined.\n\n\nCode\nround(prop.table(table(trip_duration_cais$transfers))*100, 1) # transfers percentage\n\n\n   0    1    2    3 \n22.6 55.5 19.7  2.1 \nOnly 22% of stops are directly accessible (without bus transfers). 78% are accessible with a maximum of 1 transfer, and 2.1% of stops require at least 4 buses to reach (3 transfers).\n\n\n\n\n\n\nYour turn\n\n\n\nTry to do the same math for a sunday evening.\n\n\n\n\n\n\nWe use the same code as in Isochrones.\n\n# define some parameters\nmode = c(\"SUBWAY\", \"BUS\") # TRANSIT, BUS, SUBWAY, RAIL, CAR, FERRY, WALK, BIKE, TRAM\nmode_egress = \"WALK\"\nmax_walk_time = 10 # in minutes\nmax_trip_duration = 90 # in minutes\ntime_window = 30 # in minutes\ntime_intervals &lt;- seq(0, 100, 10)\ndeparture_datetime_HP = as.POSIXct(\"01-10-2025 8:00:00\", format = \"%d-%m-%Y %H:%M:%S\") # quarta-feira\n\n# calculate travel time matrix\nttm_zer_PT_wednesday = travel_time_matrix(r5r_network = r5r_lisboa,\n                              origins = BAIXA,\n                              destinations = POINTS,\n                              mode = mode,\n                              mode_egress = mode_egress,\n                              departure_datetime = departure_datetime_HP,\n                              max_walk_time = max_walk_time,\n                              max_trip_duration = max_trip_duration,\n                              time_window = time_window,\n                              max_rides = 3, # max 1 transfer\n                              verbose = FALSE)\n\nsummary(ttm_zer_PT_wednesday$travel_time_p50)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n   1.00   29.00   37.00   36.24   43.00   65.00 \n\n\nCode\n# add coordinates of destinations to travel time matrix\nttm_zer_PT_wednesday = ttm_zer_PT_wednesday |&gt;\n  left_join(POINTS, by = c(\"to_id\" = \"id\"))\n\n# interpolate estimates to get spatially smooth result\ntravel_times.interp &lt;- with(na.omit(ttm_zer_PT_wednesday), interp(lon, lat, travel_time_p50)) |&gt;\n  with(cbind(travel_time=as.vector(z),  # Column-major order\n             x=rep(x, times=length(y)),\n             y=rep(y, each=length(x)))) |&gt;\n  as.data.frame() |&gt; na.omit()\n\n# find isochrone's bounding box to crop the map below\nbb_x &lt;- c(min(travel_times.interp$x), max(travel_times.interp$x))\nbb_y &lt;- c(min(travel_times.interp$y), max(travel_times.interp$y))\n# plot\nplotHP = ggplot(travel_times.interp) +\n  geom_contour_filled(aes(x = x, y = y, z = travel_time), alpha = .7) +\n  geom_sf(data = road_network_base, color = \"gray55\", lwd = 0.5, alpha = 0.4) +\n  geom_sf(data = city_limit, fill = \"transparent\", color = \"grey30\") +\n  geom_point(aes(x = lon, y = lat, color = 'Baixa'), data = BAIXA) +\n  scale_fill_viridis_d(direction = -1, option = 'B') +\n  scale_color_manual(values = c('Baixa' = 'black')) +\n  scale_x_continuous(expand = c(0, 0)) +\n  scale_y_continuous(expand = c(0, 0)) +\n  coord_sf(xlim = bb_x, ylim = bb_y) +\n  labs(\n    title = \"Reaching from Baixa (Carris + Metro)\",\n    subtitle = \"at 8am wednesday - 1 transf max\",\n    fill = \"Trip duration \\n[min]\",\n    color = ''\n  ) +\n  theme_minimal() +\n  theme(axis.title = element_blank())\n\nplotHP\n\n\n\n\n\n\n\n\n\n\n\ndeparture_datetime_OFF = as.POSIXct(\"05-10-2025 22:00:00\", format = \"%d-%m-%Y %H:%M:%S\") # sunday evening\n\n# calculate travel time matrix\nttm_zer_PT_sunday = travel_time_matrix(r5r_network = r5r_lisboa,\n                              origins = BAIXA,\n                              destinations = POINTS,\n                              mode = mode,\n                              mode_egress = mode_egress,\n                              departure_datetime = departure_datetime_OFF, # new date\n                              max_walk_time = max_walk_time,\n                              max_trip_duration = max_trip_duration,\n                              time_window = time_window,\n                              max_rides = 2, # max 1 transfer\n                              verbose = FALSE)\n\nsummary(ttm_zer_PT_sunday$travel_time_p50)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n   1.00   32.00   41.00   40.81   50.00   79.00 \n\n\nCode\n# add coordinates of destinations to travel time matrix\nttm_zer_PT_sunday = ttm_zer_PT_sunday |&gt;\n  left_join(POINTS, by = c(\"to_id\" = \"id\"))\n\n# interpolate estimates to get spatially smooth result\ntravel_times.interp &lt;- with(na.omit(ttm_zer_PT_sunday), interp(lon, lat, travel_time_p50)) |&gt;\n  with(cbind(travel_time=as.vector(z),  # Column-major order\n             x=rep(x, times=length(y)),\n             y=rep(y, each=length(x)))) |&gt;\n  as.data.frame() |&gt; na.omit()\n\n# find isochrone's bounding box to crop the map below\nbb_x &lt;- c(min(travel_times.interp$x), max(travel_times.interp$x))\nbb_y &lt;- c(min(travel_times.interp$y), max(travel_times.interp$y))\n# plot\nplotOFF = ggplot(travel_times.interp) +\n  geom_contour_filled(aes(x = x, y = y, z = travel_time), alpha = .7) +\n  geom_sf(data = road_network_base, color = \"gray55\", lwd = 0.5, alpha = 0.4) +\n  geom_sf(data = city_limit, fill = \"transparent\", color = \"grey30\") +\n  geom_point(aes(x = lon, y = lat, color = 'Baixa'), data = BAIXA) +\n  scale_fill_viridis_d(direction = -1, option = 'B') +\n  scale_color_manual(values = c('Baixa' = 'black')) +\n  scale_x_continuous(expand = c(0, 0)) +\n  scale_y_continuous(expand = c(0, 0)) +\n  coord_sf(xlim = bb_x, ylim = bb_y) +\n  labs(\n    title = \"Reaching from Baixa (Carris + Metro)\",\n    subtitle = \"at 10pm sunday - 1 transf max\",\n    fill = \"Trip duration \\n[min]\",\n    color = ''\n  ) +\n  theme_minimal() +\n  theme(axis.title = element_blank())\n\nplotOFF\n\n\n\n\n\n\n\n\n\n\nBased on Census 2021 (INE 2022), we can count how many people are reach.\n\n\nCode\npoplisboa = sum(POINTS$residents) #\n100* sum(ttm_zer_PT_wednesday$residents[ttm_zer_PT_wednesday$travel_time_p50 &lt;= 15]) / poplisboa # 2.8%\n100* sum(ttm_zer_PT_wednesday$residents[ttm_zer_PT_wednesday$travel_time_p50 &lt;= 30]) / poplisboa # 4.4%\n100* sum(ttm_zer_PT_wednesday$residents[ttm_zer_PT_wednesday$travel_time_p50 &lt;= 45]) / poplisboa # 90.7%\n100* sum(ttm_zer_PT_wednesday$residents[ttm_zer_PT_wednesday$travel_time_p50 &lt;= 60]) / poplisboa # 98.9%\n\n100* sum(ttm_zer_PT_sunday$residents[ttm_zer_PT_sunday$travel_time_p50 &lt;= 15]) / poplisboa # 1.3%\n100* sum(ttm_zer_PT_sunday$residents[ttm_zer_PT_sunday$travel_time_p50 &lt;= 30]) / poplisboa # 29.6%\n100* sum(ttm_zer_PT_sunday$residents[ttm_zer_PT_sunday$travel_time_p50 &lt;= 45]) / poplisboa # 73.5%\n100* sum(ttm_zer_PT_sunday$residents[ttm_zer_PT_sunday$travel_time_p50 &lt;= 60]) / poplisboa # 93.5%\n\n\n\n\n\nUp to‚Ä¶\nWednesday peak hour\nSunday evening\n\n\n\n\n30 min\n42.3%\n29.6%\n\n\n45 min\n90.7%\n73.5%\n\n\n60 min\n98.9%\n93.5%",
    "crumbs": [
      "Home",
      "r5r",
      "Scenarios"
    ]
  },
  {
    "objectID": "scenarios.html#work-day-vs.-weekend",
    "href": "scenarios.html#work-day-vs.-weekend",
    "title": "Scenarios",
    "section": "",
    "text": "With the same method presented in Accessibility, let‚Äôs compare the population that can be reach from city center on a peak hour and a Sunday evening, using public transit and max 1 transfer.\n\n\nFirst, we can have a look at the available routes on both time periods. We use tidytransit::filter_feed_by_date() function, to filter our GTFS by day and by hour.\n\n\nCode\n# Example with Carris\ncarris_different_trips_all = length(unique(gtfs_carris$trips$trip_id)) # 53028\n\n# wednesday morning\ncarris_wednesday = gtfs_carris |&gt; filter_feed_by_date(\"2025-10-01\")\ncarris_different_trips_wednesday = length(unique(carris_wednesday$trips$trip_id)) # 11504\ncarris_wednesday_peakh = gtfs_carris |&gt; filter_feed_by_date(\"2025-10-01\",\n                                                            min_departure_time = \"08:00:00\",\n                                                            max_arrival_time = \"09:00:00\")\ncarris_different_trips_wednesday_h = length(unique(carris_wednesday_peakh$trips$trip_id)) # 1352\n\n# sunday evening\ncarris_sunday = gtfs_carris |&gt; filter_feed_by_date(\"2025-10-05\")\ncarris_different_trips_sunday = length(unique(carris_sunday$trips$trip_id)) # 6268\ncarris_sunday_peakh = gtfs_carris |&gt; filter_feed_by_date(\"2025-10-05\",\n                                                          min_departure_time = \"22:00:00\",\n                                                          max_arrival_time = \"23:00:00\")\ncarris_different_trips_sunday_h = length(unique(carris_sunday_peakh$trips$trip_id)) # 264\n\n# comparision\ncarris_different_trips_sunday/carris_different_trips_wednesday # 54%\ncarris_different_trips_sunday_h/carris_different_trips_wednesday_h # 19%\n\n\nFor instance, for Carris (bus operator), on a Sunday there are 54% of the departures of a Wednesday, and on a Sunday evening (22h) there are 19% of the departures that are on a Wednesday morning (8h).\n\n\nBy considering the PTransit stops as destinations (and not population), we can also estimate how many bus stops are reachable, in total and by number of transfers needed, for each our.\nThese estimates are based on GTFS data only, and do not rely on r5r.\n\nsummary(gtfs_carris)\n\ntidygtfs object\nfiles        agency, stops, routes, trips, stop_times, calendar, calendar_dates, shapes, transfers\nagency       Carris\nservice      from 2025-09-01 to 2025-12-01\nuses         stop_times (no frequencies)\n# routes       175\n# trips      53028\n# stop_ids    2341\n# stop_names  1139\n# shapes       307\n\n# We will use the Cais Sodr√© bus stop name\nfrom_station = \"Cais Sodr√©\"\nstop_times_carris = filter_stop_times(gtfs_carris, \"2025-10-01\", \"08:00:00\", \"09:00:00\")\ntrip_duration_cais = travel_times(stop_times_carris, from_station, stop_dist_check = FALSE)\n\nnrow(trip_duration_cais) # 989\n\nsummary(trip_duration_cais$travel_time/60) # in minutos\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n   0.00   19.85   29.87   29.72   40.02   62.30 \nNot counting the waiting time at Cais do Sodr√© it is possible to reach 989 stops in the network (42%) during rush hour‚Äîwithin the 1 hour time frame defined.\n\n\nCode\nround(prop.table(table(trip_duration_cais$transfers))*100, 1) # transfers percentage\n\n\n   0    1    2    3 \n22.6 55.5 19.7  2.1 \nOnly 22% of stops are directly accessible (without bus transfers). 78% are accessible with a maximum of 1 transfer, and 2.1% of stops require at least 4 buses to reach (3 transfers).\n\n\n\n\n\n\nYour turn\n\n\n\nTry to do the same math for a sunday evening.\n\n\n\n\n\n\nWe use the same code as in Isochrones.\n\n# define some parameters\nmode = c(\"SUBWAY\", \"BUS\") # TRANSIT, BUS, SUBWAY, RAIL, CAR, FERRY, WALK, BIKE, TRAM\nmode_egress = \"WALK\"\nmax_walk_time = 10 # in minutes\nmax_trip_duration = 90 # in minutes\ntime_window = 30 # in minutes\ntime_intervals &lt;- seq(0, 100, 10)\ndeparture_datetime_HP = as.POSIXct(\"01-10-2025 8:00:00\", format = \"%d-%m-%Y %H:%M:%S\") # quarta-feira\n\n# calculate travel time matrix\nttm_zer_PT_wednesday = travel_time_matrix(r5r_network = r5r_lisboa,\n                              origins = BAIXA,\n                              destinations = POINTS,\n                              mode = mode,\n                              mode_egress = mode_egress,\n                              departure_datetime = departure_datetime_HP,\n                              max_walk_time = max_walk_time,\n                              max_trip_duration = max_trip_duration,\n                              time_window = time_window,\n                              max_rides = 3, # max 1 transfer\n                              verbose = FALSE)\n\nsummary(ttm_zer_PT_wednesday$travel_time_p50)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n   1.00   29.00   37.00   36.24   43.00   65.00 \n\n\nCode\n# add coordinates of destinations to travel time matrix\nttm_zer_PT_wednesday = ttm_zer_PT_wednesday |&gt;\n  left_join(POINTS, by = c(\"to_id\" = \"id\"))\n\n# interpolate estimates to get spatially smooth result\ntravel_times.interp &lt;- with(na.omit(ttm_zer_PT_wednesday), interp(lon, lat, travel_time_p50)) |&gt;\n  with(cbind(travel_time=as.vector(z),  # Column-major order\n             x=rep(x, times=length(y)),\n             y=rep(y, each=length(x)))) |&gt;\n  as.data.frame() |&gt; na.omit()\n\n# find isochrone's bounding box to crop the map below\nbb_x &lt;- c(min(travel_times.interp$x), max(travel_times.interp$x))\nbb_y &lt;- c(min(travel_times.interp$y), max(travel_times.interp$y))\n# plot\nplotHP = ggplot(travel_times.interp) +\n  geom_contour_filled(aes(x = x, y = y, z = travel_time), alpha = .7) +\n  geom_sf(data = road_network_base, color = \"gray55\", lwd = 0.5, alpha = 0.4) +\n  geom_sf(data = city_limit, fill = \"transparent\", color = \"grey30\") +\n  geom_point(aes(x = lon, y = lat, color = 'Baixa'), data = BAIXA) +\n  scale_fill_viridis_d(direction = -1, option = 'B') +\n  scale_color_manual(values = c('Baixa' = 'black')) +\n  scale_x_continuous(expand = c(0, 0)) +\n  scale_y_continuous(expand = c(0, 0)) +\n  coord_sf(xlim = bb_x, ylim = bb_y) +\n  labs(\n    title = \"Reaching from Baixa (Carris + Metro)\",\n    subtitle = \"at 8am wednesday - 1 transf max\",\n    fill = \"Trip duration \\n[min]\",\n    color = ''\n  ) +\n  theme_minimal() +\n  theme(axis.title = element_blank())\n\nplotHP\n\n\n\n\n\n\n\n\n\n\n\ndeparture_datetime_OFF = as.POSIXct(\"05-10-2025 22:00:00\", format = \"%d-%m-%Y %H:%M:%S\") # sunday evening\n\n# calculate travel time matrix\nttm_zer_PT_sunday = travel_time_matrix(r5r_network = r5r_lisboa,\n                              origins = BAIXA,\n                              destinations = POINTS,\n                              mode = mode,\n                              mode_egress = mode_egress,\n                              departure_datetime = departure_datetime_OFF, # new date\n                              max_walk_time = max_walk_time,\n                              max_trip_duration = max_trip_duration,\n                              time_window = time_window,\n                              max_rides = 2, # max 1 transfer\n                              verbose = FALSE)\n\nsummary(ttm_zer_PT_sunday$travel_time_p50)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n   1.00   32.00   41.00   40.81   50.00   79.00 \n\n\nCode\n# add coordinates of destinations to travel time matrix\nttm_zer_PT_sunday = ttm_zer_PT_sunday |&gt;\n  left_join(POINTS, by = c(\"to_id\" = \"id\"))\n\n# interpolate estimates to get spatially smooth result\ntravel_times.interp &lt;- with(na.omit(ttm_zer_PT_sunday), interp(lon, lat, travel_time_p50)) |&gt;\n  with(cbind(travel_time=as.vector(z),  # Column-major order\n             x=rep(x, times=length(y)),\n             y=rep(y, each=length(x)))) |&gt;\n  as.data.frame() |&gt; na.omit()\n\n# find isochrone's bounding box to crop the map below\nbb_x &lt;- c(min(travel_times.interp$x), max(travel_times.interp$x))\nbb_y &lt;- c(min(travel_times.interp$y), max(travel_times.interp$y))\n# plot\nplotOFF = ggplot(travel_times.interp) +\n  geom_contour_filled(aes(x = x, y = y, z = travel_time), alpha = .7) +\n  geom_sf(data = road_network_base, color = \"gray55\", lwd = 0.5, alpha = 0.4) +\n  geom_sf(data = city_limit, fill = \"transparent\", color = \"grey30\") +\n  geom_point(aes(x = lon, y = lat, color = 'Baixa'), data = BAIXA) +\n  scale_fill_viridis_d(direction = -1, option = 'B') +\n  scale_color_manual(values = c('Baixa' = 'black')) +\n  scale_x_continuous(expand = c(0, 0)) +\n  scale_y_continuous(expand = c(0, 0)) +\n  coord_sf(xlim = bb_x, ylim = bb_y) +\n  labs(\n    title = \"Reaching from Baixa (Carris + Metro)\",\n    subtitle = \"at 10pm sunday - 1 transf max\",\n    fill = \"Trip duration \\n[min]\",\n    color = ''\n  ) +\n  theme_minimal() +\n  theme(axis.title = element_blank())\n\nplotOFF\n\n\n\n\n\n\n\n\n\n\nBased on Census 2021 (INE 2022), we can count how many people are reach.\n\n\nCode\npoplisboa = sum(POINTS$residents) #\n100* sum(ttm_zer_PT_wednesday$residents[ttm_zer_PT_wednesday$travel_time_p50 &lt;= 15]) / poplisboa # 2.8%\n100* sum(ttm_zer_PT_wednesday$residents[ttm_zer_PT_wednesday$travel_time_p50 &lt;= 30]) / poplisboa # 4.4%\n100* sum(ttm_zer_PT_wednesday$residents[ttm_zer_PT_wednesday$travel_time_p50 &lt;= 45]) / poplisboa # 90.7%\n100* sum(ttm_zer_PT_wednesday$residents[ttm_zer_PT_wednesday$travel_time_p50 &lt;= 60]) / poplisboa # 98.9%\n\n100* sum(ttm_zer_PT_sunday$residents[ttm_zer_PT_sunday$travel_time_p50 &lt;= 15]) / poplisboa # 1.3%\n100* sum(ttm_zer_PT_sunday$residents[ttm_zer_PT_sunday$travel_time_p50 &lt;= 30]) / poplisboa # 29.6%\n100* sum(ttm_zer_PT_sunday$residents[ttm_zer_PT_sunday$travel_time_p50 &lt;= 45]) / poplisboa # 73.5%\n100* sum(ttm_zer_PT_sunday$residents[ttm_zer_PT_sunday$travel_time_p50 &lt;= 60]) / poplisboa # 93.5%\n\n\n\n\n\nUp to‚Ä¶\nWednesday peak hour\nSunday evening\n\n\n\n\n30 min\n42.3%\n29.6%\n\n\n45 min\n90.7%\n73.5%\n\n\n60 min\n98.9%\n93.5%",
    "crumbs": [
      "Home",
      "r5r",
      "Scenarios"
    ]
  },
  {
    "objectID": "scenarios.html#new-metro-station-or-metro-line",
    "href": "scenarios.html#new-metro-station-or-metro-line",
    "title": "Scenarios",
    "section": "New metro station or metro line",
    "text": "New metro station or metro line\nLet‚Äôs create a new metro line or a new station in your city.\n\n\n\nNew pink line (expansion in Lisbon)\n\n\n\nMethodology\nFor that, an easy graphic interface software is the PTV Lines.\n\nLogin into PTV Lines (upper right corner) with the credentials that were sent to you.\nCreate a new scenario, and import an existing subway gtfs (.zip) - max 50 lines!1\nEdit that scenario by creating stops and lines.\nExport the GTFS file.\nDuplicate your r5r folder (baseline scenario) and delete the network.dat file inside. Rename it as ..._ver1 and replace the gtfs.zip by the one you just exported.\nBuild a new network with that folder path.\n\n\n\nCreate a metro line with PTV Lines\nFirst, create new station points (S) and name them. As many as you need.\n\n\n\n\n\n\n\n\n\n\nThen, create a new line (L), name it something like ‚ÄúExpansion‚Äù, and create a new route (R). Name it 0 (you can edit later) and draw that line roughly by selecting an existing start station and connecting to your new stations.\n\n\n\n\n\nAdd trips to it (T), with a proper headway.\n\n\n\n\n\nAfter defining the weekday and weekend trips, go to the Outbound route and ‚ÄúCreate opposite direction‚Äù, so you can have both directions now. Rename the line routes, something as ‚ÄúStart station - End station‚Äù.\n\n\n\n\n\n\n\nExtend a metro line with PTV Lines\nThis tutorial assumes that the stations for which the line will be extended to already exist (if not, see how to create new stations at Create a metro line with PTV Lines).\nThe extension is performed over a route. To access one, click on a transit line, and then on one of its routes.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nOn the map, hover the Start/End buttons and click it to enable the extension mode.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nOnce the extension mode is activated, your cursor will turn into a pen icon and you just have to click on the station you want to expand your line to.\n\n\n\n\n\n\nRouting modes\n\n\n\nBe aware of the several modes available on the button that is now displayed (automatic routing mode, street routing mode, straight line mode or exclusive PT routing mode). Make sure you use the one that best suits your use case.\n\n\n\n\n\n\n\nOnce you click on the station, you should see the new station in the route window, on the left part of the screen. You should adjust the run and dwell times accordingly.\n\n\n\n\n\n\n\nVisualizing time diagram\nGo to Connections, and click on a connecting station to visualize the time diagram of connections with other routes.\n\n\n\n\n\n\n\nGenerate GTFS\nAfter all your edits, go back to the dashboard, and click on ‚ÄúExport supply‚Äù. Export as GTFS (.zip)\n\nYour scenario will be saved in your dashboard. You can edit or duplicate them later.\n\n\n\n\n\n\nYour task\n\n\n\nRun some routing and accessibility analysis, and compare with the baseline scenario.\nConsider comparing the estimated cost of your new infrastructure and the mobility gains.\n\n\nSee Pereira and Herszenhut (2023) Chapter 6 for an example.\nIf you do multi-modal analysis, you may need to use GTFShift::unify() to merge the new gtfs with other modes and create new transfers.\nIf you have more than 50 lines, consider filtering your GTFS by area or by mode, and use that one as the baseline scenario, and the improved one (PTV lines) as you comparison scenario.\n\n\nCode example to filter a gtfs by mode\n# example to filter a gtfs by mode = TRAM\ngtfs_all_modes = gtfstools::read_gtfs(\"data/gtfs_all.zip\")\ngtfs_tram = gtfstools::filter_by_route_type(gtfs_all_modes,\n                                            route_type = 0) # see the documentation for the other modes' code\ngtfstools::write_gtfs(\"data/gtfs_tram-zip\")",
    "crumbs": [
      "Home",
      "r5r",
      "Scenarios"
    ]
  },
  {
    "objectID": "scenarios.html#footnotes",
    "href": "scenarios.html#footnotes",
    "title": "Scenarios",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nTip: you may need to filter by a mode (tram, or subway) to avoid having more than 50 lines.‚Ü©Ô∏é",
    "crumbs": [
      "Home",
      "r5r",
      "Scenarios"
    ]
  },
  {
    "objectID": "vissim.html",
    "href": "vissim.html",
    "title": "Vissim",
    "section": "",
    "text": "This tutorial is only for Windows\n\n\n\nIf you do not use Windows, you need to have a Virtual Machine. If you have an Arm processor this won‚Äôt work, even with a VM.\nIn this tutorial we will guide you to install and start using Vissim.\nPTV Vissim is a micro simulation software, non-free, available only for Windows OS.",
    "crumbs": [
      "Home",
      "Software",
      "VISSIM"
    ]
  },
  {
    "objectID": "vissim.html#vissim-install",
    "href": "vissim.html#vissim-install",
    "title": "Vissim",
    "section": "Installation",
    "text": "Installation\nPTV Vissim is available to download at: https://cgi.ptvgroup.com/visionSetups/en/filter;product=PTV%20Vissim\n\nChoose the most recent version (recommended) ‚â§ 2024. The file may be more than 1.3 GB.\nIf you don‚Äôt have Python installed already in your PC, don‚Äôt worry, you can opt to install it along the Vissim setup.\nThe available instructions are very straight forward.\n\nLicence activation\n\nYou should have received a server address of where the CERIS licence lives. If not, contact the course teacher.\n\nTo use Vissim with the CERIS licence, you need to download PTV Licence Manager (Standard).\n\nIt will ask you to download also another tiny software CodeMeter Runtime. Say yes!\nAfter install it, open PTV Licence Manager, and click on ‚öôÔ∏è Edit CodeMeter settings:\n\nAdd ‚ûï CodeMeter server, and insert the server address that was sent to you.\n\nPress close (go back) and now üîç Find Licences.\n\nAn available licence row should now appear on the list üéâ. Close it.",
    "crumbs": [
      "Home",
      "Software",
      "VISSIM"
    ]
  },
  {
    "objectID": "vissim.html#getting-started",
    "href": "vissim.html#getting-started",
    "title": "Vissim",
    "section": "Getting started",
    "text": "Getting started\nWhen launching Vissim for the first time, you should have something like this. This is a good signal, it means that the connection to the licence server is running smoothly and that you are ready to start working on your projects! üöÄ\n\nThe ‚ÄúTutorial First Steps‚Äù may be wise to follow if you are not familiar with the software. It covers the following topics:\n\nDeveloping the network\nRun Simulation\nSignal control\n\nPTV also offers online tutorials to get familiar with the software.",
    "crumbs": [
      "Home",
      "Software",
      "VISSIM"
    ]
  },
  {
    "objectID": "visum.html",
    "href": "visum.html",
    "title": "Visum",
    "section": "",
    "text": "This tutorial is only for Windows\n\n\n\nIf you do not use Windows, you need to have a Virtual Machine. If you have an Arm processor this won‚Äôt work, even with a VM.\nIn this tutorial we will guide you to install and start using Visum.\nPTV Visum is a macro simulation software, non-free, available only for Windows OS.",
    "crumbs": [
      "Home",
      "Software",
      "VISUM"
    ]
  },
  {
    "objectID": "visum.html#installation",
    "href": "visum.html#installation",
    "title": "Visum",
    "section": "Installation",
    "text": "Installation\nPTV Visum is available to download at: https://cgi.ptvgroup.com/visionSetups/en/filter;product=PTV%20Visum\nChoose the most recent version (recommended) ‚â§ 2024. The file may be more than 1.3 GB.\nIf you don‚Äôt have Python installed already in your PC, don‚Äôt worry, you can opt to install it along the Visum setup.\nThe available instructions are very straight forward.\n\nLicence activation\n\nYou should have received a server address of where the CERIS licence lives. If not, contact the course teacher.\n\nTo use Visum with the CERIS licence, you need to download PTV Licence Manager (Standard).\n\nIt will ask you to download also another tiny software CodeMeter Runtime. Say yes!\nAfter install it, open PTV Licence Manager, and click on ‚öôÔ∏è Edit CodeMeter settings:\n\nAdd ‚ûï CodeMeter server, and insert the server address that was sent to you.\n\nPress close (go back) and now üîç Find Licences.\n\nAn available licence row should now appear on the list üéâ. Close it.\n\n\n\n\n\n\nFor any reason üßô‚Äç‚ôÇÔ∏è the licence is not accessed if you are connected to the IST DECivil ethernet network.",
    "crumbs": [
      "Home",
      "Software",
      "VISUM"
    ]
  },
  {
    "objectID": "visum.html#getting-started",
    "href": "visum.html#getting-started",
    "title": "Visum",
    "section": "Getting started",
    "text": "Getting started\nWhen launching Visum for the first time, you should have something like this. This is a good signal, it means that the connection to the licence server is running smoothly and that you are ready to start working on your projects! üöÄ\n\nThe ‚ÄúTutorial First Steps‚Äù may be wise to follow if you are not familiar with the software. It covers the following topics:\n\nNetwork editing (private and public transport)\nProcedure sequence\nGraphic parameters\n\nPTV also offers online tutorials to get familiar with the software.",
    "crumbs": [
      "Home",
      "Software",
      "VISUM"
    ]
  },
  {
    "objectID": "sumo.html",
    "href": "sumo.html",
    "title": "SUMO",
    "section": "",
    "text": "In this tutorial we will guide you to install and start using SUMO.\nSUMO is a free and open source traffic simulation suite. It is available since 2001 and allows modelling of intermodal traffic systems - including road vehicles, public transport and pedestrians. Included with SUMO is a wealth of supporting tools which automate core tasks for the creation, the execution and evaluation of traffic simulations, such as network import, route calculations, visualization and emission calculation (Lopez et al. 2018).\nSUMO is available for any operating system.",
    "crumbs": [
      "Home",
      "Software",
      "SUMO"
    ]
  },
  {
    "objectID": "sumo.html#installation",
    "href": "sumo.html#installation",
    "title": "SUMO",
    "section": "Installation",
    "text": "Installation\n\nWindows\nThe installation of SUMO in Windows is pretty straightforward.\nVisit https://eclipse.dev/sumo/ and download the installation file (137 MB).\n\nOpen the downloaded file and execute in your computer. Accept the defaults and install.\n\n\nMac OS\n\nsoon. üêº\n\n\n\nLinux\nIn debian based (ubuntu, kubuntu, popOS, debian) follow this instructions.\n\nsoon. üêß",
    "crumbs": [
      "Home",
      "Software",
      "SUMO"
    ]
  },
  {
    "objectID": "sumo.html#getting-started",
    "href": "sumo.html#getting-started",
    "title": "SUMO",
    "section": "Getting started",
    "text": "Getting started\nOpen SUMO-gui (Graphic User Interface). You should have a window like this:\n\nSeveral tutorials are available. Try these ones:\n\nHello World - Creating a simple network and demand scenario with netedit and visualizing it using sumo-gui\nOSMWebWizard - Setting up a scenario with just a few clicks using osmWebWizard.py; getting a network from OpenStreetMap\nQuick Start - A more complex tutorial with netedit; first steps in SUMO\nDriving in Circles - Work with netedit; define a flow; let vehicles drive in circles using rerouters\nSUMOlympics - Create special lanes and simple traffic lights in netedit, more about flows and vehicle types, working with vehicle\nAutobahn - Build a highway, create a mixed highway flow, visualize vehicle speed, save view settings\nImporting GTFS - Importing public transport schedules from public sources using the General Transit Feed Specification\n\n\n\nImport from OpenStreetMap\nThis requires having Python installed.\n\nWindows: Start -&gt; All Programs -&gt; OSM Web Wizard\nMacOS: üêº\nLinux (terminal):\n\ncd ~/sumo/tools\npython3 osmWebWizard.py\nAnd a window will open in your browser.\n\nYou may zoom and pan to the area of your interest1. Click on ‚ÄúSelect Area‚Äù and draw a rectangle with your mouse for which you wish to generate the simulation scenario.\n\nNetwork Generation\nThe infrastructure import from OSM into the SUMO simulation are affected by different Wizard options\n\nby default the ‚ÄúAdd Polygon‚Äù checkbox is checked and a road traffic simulation is generated but all types of roads and rails will be imported as well (cycle paths, footpaths, railways etc)\nif the checkbox ‚Äúleft-hand Traffic‚Äù is enabled, the network will be built with left hand traffic rules. For most geographic regions where this is required, this feature will be enabled automatically but if it does not work, this option can be used as a remedy.\nif the checkbox ‚ÄúCar-only Network‚Äù is enabled, then only roads that permit passenger car traffic will be included. This can be used to reduce the network size and also helps to reduce intersection complexity\nif the checkbox ‚ÄúImport Public Transport‚Äù is enabled, then busStops and trainStops will be exported. Also busses, trams and trains will be generated that follow the public transport routes defined in OSM (but they will follow synthetic schedules).\nif the Demand-checkbox ‚ÄúBicycles‚Äù is active, then extra bicycle lanes will be added to roads where OSM contains this information\nif the Demand-checkbox ‚ÄúPedestrians‚Äù is active, then sidewalks and pedestrian crossings will be generated\n\n\n\nDemand Generation\nThe demand is defined by the demand generation panel. You activate this panel by clicking on the car pictogram.\n\nSUMO supports various modes of transport. At the demand generation panel, you can activate/deactivate the individual modes of transport by clicking the corresponding checkboxes. For each mode of transport, the OSM Web Wizard generates random demand based on a certain probability distribution, which is influenced by two parameters:\n\nEvery time a new vehicle is generated, the OSM Web Wizard randomly chooses a departure and arrival edge for the vehicle. The Through Traffic Factor defines how many times it is more likely for an edge at the boundary of the simulation area being chosen, compared to an edge entirely located inside the simulation area. A big value for the Through Traffic Factor implies that many vehicles depart and arrive at the boundary of the simulation area, which corresponds to a scenario with a lot of through traffic.\nThe Count parameter defines how many vehicles are generated per hour and lane-kilometer. Assuming\n\nthe network contains 3 edges with a combined length of 5 km\nthat each has 2 lanes which allows the current traffic mode\nand the count value is set to 90,\nthen 5 * 2 * 90 = 900 vehicles per hour will be generated.\n\n\nThis translates to a randomTrips parameter of p=4 which means a new vehicle is inserted every 4 seconds somewhere in the network.\nThe next step is generating and running the scenario.\n\n\nRoad-Type Selection\nIn the Road-Type tab of the OSM Web Wizard one can define which road types to be downloaded and rendered.\n\nFor example, one can only choose motorways, primary, secondary and tertiary to simulate major traffic. This impacts the file size of the OSM map data.\nBy default, all road types are checked which implies downloading and rendering all roads.\nUnchecking the ‚ÄúAdd Polygon‚Äù checkbox in the Demand Generation section disables downloading and rendering non-road objects like buildings, waterways, etc. resulting in a smaller file size.\n\n\nGenerating and Running the scenario\nThe complete scenario will be generated automatically once Generate Scenario in the control panel has been clicked. The scenario generation takes a couple of seconds or minutes (depending, among other factors, on the size of the scenario).\nOnce the scenario generation process has finished, the sumo-gui starts and the simulation can be started by pressing the Play button.\n You will see agents making their trips. Adjust the Delay to make it faster or slower.\n\nA new directory under your user folder ~/SUMO/yyyy-mm-dd-hh-mm-ss will be created to host the data and results. You may now edit those files and re-run the simulation (open run file).\n\n\n\nUse the case study data\n\nSoon ü•Ω",
    "crumbs": [
      "Home",
      "Software",
      "SUMO"
    ]
  },
  {
    "objectID": "sumo.html#footnotes",
    "href": "sumo.html#footnotes",
    "title": "SUMO",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nCaution: if the map excerpt covers a very large area, the simulation might become slow or even unresponsive. We suggest choosing a similar zoom level as in the initial view.‚Ü©Ô∏é",
    "crumbs": [
      "Home",
      "Software",
      "SUMO"
    ]
  }
]